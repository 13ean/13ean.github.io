<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="13ean">
  
  
  
  <link rel="prev" href="https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" />
  <link rel="next" href="https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" />
  <link rel="canonical" href="https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" />
  <link rel="apple-touch-icon" sizes="180x180" href="https://13ean.github.io/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://13ean.github.io/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://13ean.github.io/favicon-16x16.png">
  <link rel="manifest" href="https://13ean.github.io/site.webmanifest">
  <link rel="mask-icon" href="https://13ean.github.io/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           计算机网络基础 | 13ean&#39;s Github Page
       
  </title>
  <meta name="title" content="计算机网络基础 | 13ean&#39;s Github Page">
    
  
  <link rel="stylesheet" href="https://13ean.github.io/font/iconfont.css">
  <link rel="stylesheet" href="https://13ean.github.io/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://13ean.github.io"
    },
    "articleSection" : "posts",
    "name" : "计算机网络基础",
    "headline" : "计算机网络基础",
    "description" : "计算机网络模型 OSI 七层模型  物理层
 传输单位：比特 Bit 功能作用：确定与传输媒介的接口的一些特性，电气，机械，功能，规程特性 设备：中继器，集线器 协议：RJ45等   数据链路层
 数据链路层可以划分为：逻辑链路控制（LLC）子层和介质访问控制（MAC）子层 传输单位：帧 Frame 功能作用：  链路管理：链路的建立、维持和释放 帧同步：确定帧的开始与结束 流量控制：点对点的，即链路层的相邻设备，采用滑动窗口机制 差错控制：将有差错的物理线路改进为对网络层来说无差错的数据链路，采用奇偶校检码和循环冗余编码（CRC） 透明传输：使得不论什么样的比特组合都可以在数据链路层传输 物理寻址：向每个帧的头部加入了源MAC地址和目的MAC地址 访问控制：当单个线路被多个设备共享时，数据链路层的MAC子层用于帮助确定哪个设备在给定时间控制信道  设备：网桥，交换机 协议：HDLC协议，PPP协议，ARP  网络层
 传输单位：数据包（分组） Packet 功能作用：  路由转发：确定哪条路由适合从源到目的地 逻辑寻址：向数据包头部加入了目的IP地址和源IP地址  设备：路由器 协议：IP，ICMP，IGMP，RIP，OSPF，BGP，RARP  传输层
 传输单位：数据报（报文）Segments 功能作用：  提供面向连接的TCP和无连接的UDP   会话层
 主要为两个会话层实体进行会话，而进行的对话连接的管理服务。提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点，可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。 功能作用：对话管理，数据流同步和重新同步  表示层
 处理两个应用实体之间进行数据交换的语法问题，解决数据交换中存在的语法不一致以及数据表示方法不同等问题 功能作用：数据编码的转换，数据加密与解密，数据压缩与恢复  应用层
 直接提供文件传输，电子邮件，网页浏览等服务给用户。 协议：FTP，SMTP，POP3，HTTP，SSH，DNS   TCP/IP模型  网络接口层 网际层 传输层 应用层  路由算法 内部网关协议 IGP 用于自治系统内部的路由协议",
    "inLanguage" : "zh-CN",
    "author" : "13ean",
    "creator" : "13ean",
    "publisher": "13ean",
    "accountablePerson" : "13ean",
    "copyrightHolder" : "13ean",
    "copyrightYear" : "2019",
    "datePublished": "2019-03-26 00:00:00 &#43;0000 UTC",
    "dateModified" : "2019-03-26 00:00:00 &#43;0000 UTC",
    "url" : "https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/",
    "wordCount" : "365",
    "keywords" : [ "network", "13ean&#39;s Github Page"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://13ean.github.io">13ean&#39;s Github Page</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="https://13ean.github.io/" title="">13ean</a>
                
                <a class="menu-item" href="https://13ean.github.io/posts/" title="">Blog</a>
                
                <a class="menu-item" href="https://13ean.github.io/categories/" title="">Categories</a>
                
                <a class="menu-item" href="https://13ean.github.io/tags/" title="">Tags</a>
                
                <a class="menu-item" href="https://13ean.github.io/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://13ean.github.io">13ean&#39;s Github Page</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="https://13ean.github.io/" title="">13ean</a>
                
                <a class="menu-item" href="https://13ean.github.io/posts/" title="">Blog</a>
                
                <a class="menu-item" href="https://13ean.github.io/categories/" title="">Categories</a>
                
                <a class="menu-item" href="https://13ean.github.io/tags/" title="">Tags</a>
                
                <a class="menu-item" href="https://13ean.github.io/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">计算机网络基础</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://13ean.github.io" rel="author">13ean</a> with ♥ 
                <span class="post-time">
                on <time datetime=2019-03-26 itemprop="datePublished">March 26, 2019</time>
                </span>
                in
                
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="计算机网络模型">计算机网络模型</h1>

<h2 id="osi-七层模型">OSI 七层模型</h2>

<ol>
<li><p>物理层</p>

<ul>
<li>传输单位：比特 Bit</li>
<li>功能作用：确定与传输媒介的接口的一些特性，电气，机械，功能，规程特性</li>
<li>设备：中继器，集线器</li>
<li>协议：RJ45等
<br></li>
</ul></li>

<li><p>数据链路层</p>

<ul>
<li>数据链路层可以划分为：逻辑链路控制（LLC）子层和介质访问控制（MAC）子层</li>
<li>传输单位：帧 Frame</li>
<li>功能作用：

<ul>
<li>链路管理：链路的建立、维持和释放</li>
<li>帧同步：确定帧的开始与结束</li>
<li>流量控制：点对点的，即链路层的相邻设备，采用滑动窗口机制</li>
<li>差错控制：将有差错的物理线路改进为对网络层来说无差错的数据链路，采用奇偶校检码和循环冗余编码（CRC）</li>
<li>透明传输：使得不论什么样的比特组合都可以在数据链路层传输</li>
<li>物理寻址：向每个帧的头部加入了源MAC地址和目的MAC地址</li>
<li>访问控制：当单个线路被多个设备共享时，数据链路层的MAC子层用于帮助确定哪个设备在给定时间控制信道</li>
</ul></li>
<li>设备：网桥，交换机</li>
<li>协议：HDLC协议，PPP协议，ARP</li>
</ul></li>

<li><p>网络层</p>

<ul>
<li>传输单位：数据包（分组） Packet</li>
<li>功能作用：

<ul>
<li>路由转发：确定哪条路由适合从源到目的地</li>
<li>逻辑寻址：向数据包头部加入了目的IP地址和源IP地址</li>
</ul></li>
<li>设备：路由器</li>
<li>协议：IP，ICMP，IGMP，RIP，OSPF，BGP，RARP</li>
</ul></li>

<li><p>传输层</p>

<ul>
<li>传输单位：数据报（报文）Segments</li>
<li>功能作用：

<ul>
<li>提供面向连接的TCP和无连接的UDP</li>
</ul></li>
</ul></li>

<li><p>会话层</p>

<ul>
<li>主要为两个会话层实体进行会话，而进行的对话连接的管理服务。提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点，可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。</li>
<li>功能作用：对话管理，数据流同步和重新同步</li>
</ul></li>

<li><p>表示层</p>

<ul>
<li>处理两个应用实体之间进行数据交换的语法问题，解决数据交换中存在的语法不一致以及数据表示方法不同等问题</li>
<li>功能作用：数据编码的转换，数据加密与解密，数据压缩与恢复</li>
</ul></li>

<li><p>应用层</p>

<ul>
<li>直接提供文件传输，电子邮件，网页浏览等服务给用户。</li>
<li>协议：FTP，SMTP，POP3，HTTP，SSH，DNS</li>
</ul></li>
</ol>

<h2 id="tcpip模型">TCP/IP模型</h2>

<ol>
<li>网络接口层</li>
<li>网际层</li>
<li>传输层</li>
<li>应用层</li>
</ol>

<h1 id="路由算法">路由算法</h1>

<h2 id="内部网关协议-igp">内部网关协议 IGP</h2>

<p>用于自治系统内部的路由协议</p>

<h3 id="rip协议">RIP协议</h3>

<h4 id="特点">特点</h4>

<ul>
<li>基于Bellman-Ford（距离矢量）算法</li>
<li>RIP使用跳数来衡量距离，每一条链路的成本为1，不考虑带宽，时延等因素</li>
<li>跳数为<strong>16</strong>，表示该网络<strong>不可达</strong></li>
<li>使用UDP报文进行路由信息的交换</li>
<li>RIP路由协议用“更新（UNPDATES）”和“请求（REQUESTS）”这两种分组来传输信息</li>
<li>每隔30秒向<strong>相邻</strong>路由器发送一次更新信息，若180秒内未收到某邻居发送的报文，则将该路由置为不可达，若300秒内未接收到，则将其从路由表中删除</li>
<li>更新信息反映了该路由器所有的路由选择信息数据库，路由选择信息数据库的每个条目由“局域网上能达到的IP地址”和“与该网络的距离”两部分组成</li>
<li>请求信息用于寻找网络上能发出RIP报文的其他设备</li>
</ul>

<h4 id="慢收敛问题">慢收敛问题</h4>

<p>任何距离向量路由选择协议（如RIP）都有一个问题，路由器不知道网络的全局情况，路由器必须依靠相邻路由器来获取网络的可达信息。由于路由选择更新信息在网络上传播慢，距离向量路由选择算法有一个慢收敛问题，这个问题将导致不一致性产生。</p>

<h4 id="更新算法">更新算法</h4>

<p>假设路由器A，收到了其邻居路由器B发来的更新信息</p>

<ul>
<li>首先对更新信息中的所有距离加1</li>
<li>若A中的路由表没有该网络的路由信息，则加入该网络，下一跳设置为B</li>
<li>若A中路由表存在该网络，且下一跳为B，则更新该网络的距离</li>
<li>若A中路由表存在该网络，下一跳不为B，且其距离小于当前距离，则更新下一跳为B，更新距离</li>
<li>若A中路由表存在该网络，下一跳不为B，且其距离不小于当前距离，则不更新</li>
<li>对于A中路由表存在的网络，但是更新信息中没有的网络，则不更新</li>
</ul>

<h3 id="ospf协议">OSPF协议</h3>

<p>开放最短路径优先（OSPF）是链路状态路由协议，使用Dijkstra算法找到源路由器和目的地路由器之间的最佳路径。链路状态路由协议是使用触发更新的概念的协议。即，如果在学习的路由表中观察到变化，则触发更新，而不像距离矢量路由协议在一段时间内交换。</p>

<h4 id="特点-1">特点</h4>

<ul>
<li>与大多数路由协议不同（参考BGP和RIP的工作过程），本协议不依赖于传输层协议（如TCP、UDP）提供数据传输、错误检测与恢复服务，数据包直接封装在IP协议（协议号89）内传输</li>
<li>使用Dijkstra算法计算出到达每一网络的最短路径</li>
</ul>

<h2 id="外部网关协议-egp">外部网关协议 EGP</h2>

<p>用于自治系统间接口上的路由协议</p>

<h3 id="bgp协议">BGP协议</h3>

<p>BGP用于在不同的自治系统（AS）之间交换路由信息，运行在TCP协议之上。当两个AS需要交换路由信息时，每个AS都必须指定一个运行BGP的节点，来代表AS与其他的AS交换路由信息。这个节点可以是一个主机。但通常是路由器来执行BGP。两个AS中利用BGP交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）。</p>

<h1 id="tcp协议">TCP协议</h1>

<h2 id="特点-2">特点</h2>

<ul>
<li>TCP是面向连接的，在传输数据之前必须先建立连接，传输完毕后释放连接</li>
<li>TCP只支持点对点通信</li>
<li>TCP提供可靠交付，保证数据无差错，不丢失，无重复，有序到达</li>
<li>TCP提供全双工通信，双方都可以发送和接收数据</li>
<li>面向字节流</li>
</ul>

<h2 id="tcp可靠传输">TCP可靠传输</h2>

<h3 id="差错控制">差错控制：</h3>

<ul>
<li>校验和：每个TCP报文段都包括检验和字段，校验和用来检查报文段是否出现传输错误，如果报文段出现传输错误，TCP检查出错就丢弃该报文段</li>
</ul>

<h3 id="编号与确认">编号与确认</h3>

<ul>
<li>TCP为报文编号，以实现报文的有序接收</li>
<li>接收端检查报文是否出错，发现出错时就丢弃，不发确认；而发送端通过检查接收端的确认，判断发送的报文段是否已经正确到达目的地</li>
</ul>

<h3 id="超时重传">超时重传</h3>

<ul>
<li>发送端根据发出的报文段在规定的时间内是否收到确认，从而来判断该报文段是否丢失或传输出错。超过一定时间未收到确认，则重新发送该报文段</li>
</ul>

<h2 id="tcp流量控制与拥塞控制">TCP流量控制与拥塞控制</h2>

<h3 id="滑动窗口">滑动窗口：</h3>

<ul>
<li>停止等待协议：发送窗口swnd=1，接收窗口rwnd=1

<ul>
<li>发送方每发送一个报文，则直到接收到接收方的确认报文才发送下一个报文</li>
</ul></li>
<li>后退N协议：发送窗口swnd&gt;1，接受窗口rwnd=1

<ul>
<li>发送方可以连续发送发送窗口内的报文，每当接收到一个错误帧，则需要重传该帧及之后的所有帧</li>
</ul></li>
<li>选择重传协议：发送窗口swnd&gt;1，接收窗口rwnd&gt;1

<ul>
<li>只重传错误帧即可</li>
</ul></li>
</ul>

<h3 id="慢启动与拥塞避免">慢启动与拥塞避免</h3>

<h4 id="慢启动算法">慢启动算法</h4>

<ul>
<li>初始时，设置拥塞窗口cwnd=1，表示可以传输一个最大的报文段MSS的数据，设置慢启动门限初值ssthresh</li>
<li>当cwnd &lt; ssthresh 时，每收到新报文的ACK，则拥塞窗口cwnd++，因此每过一个RTT，则cwnd*2，呈指数增长</li>
<li>当cwnd &gt;= ssthresh 时，改用拥塞避免算法
<br></li>
</ul>

<h4 id="拥塞避免算法">拥塞避免算法</h4>

<ul>
<li>当 cwdn &gt;= ssthresh 时，每过一个RTT，拥塞窗口cwnd++</li>
</ul>

<h4 id="超时重传拥塞发生">超时重传（拥塞发生）</h4>

<ul>
<li>将ssthresh置为拥塞发生时拥塞窗口cwnd大小的一半</li>
<li>拥塞窗口cwnd大小置为1，改用慢启动算法</li>
</ul>

<h3 id="快重传与快恢复">快重传与快恢复</h3>

<h4 id="快重传">快重传</h4>

<ul>
<li>每当发送端接收到三个重复确认帧时，则直接开启重传，而不等待RTO超时</li>
</ul>

<h4 id="快恢复">快恢复</h4>

<ul>
<li>重新将慢开始门限ssthresh设置为拥塞窗口cwnd的一半</li>
<li>将拥塞窗口cwnd设置为ssthresh，然后采用拥塞避免算法</li>
</ul>

<h3 id="流量控制和拥塞控制的区别">流量控制和拥塞控制的区别：</h3>

<ul>
<li>流量控制是针对点对点的通信量的控制，是端到端的问题。流量控制所作的就是控制发送端的发送速率，以使得接收端能够接收。</li>
<li>而拥塞控制是止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</li>
</ul>

<h2 id="tcp连接管理">TCP连接管理</h2>

<h3 id="tcp的建立过程">TCP的建立过程</h3>

<ul>
<li>首先client发送连接请求，发送TCP报文，其中SYN=1， seq=x，然后clien进入<strong>SYN_SEND</strong>状态</li>
<li>server接收到连接请求，发送TCP报文，进行确认，其中SYN=1，ACK=1，seq=y，ack=x+1，然后server进入<strong>SYN_RCVD</strong>状态</li>
<li>clieten收到server发送过来的报文后，进行确认，其中ACK=1，seq=x+1，ack=y+1，然后client进入<strong>ESTABLISHED</strong>状态</li>
<li>server接收到该报文后也进入<strong>ESTABLISHED</strong>状态</li>
</ul>

<h3 id="tcp释放连接过程">TCP释放连接过程</h3>

<ul>
<li>A发送断开连接请求，发送TCP报文，其中FIN=1，seq=x，然后A进入<strong>FIN_WAIT_1</strong>状态</li>
<li>B接收到A发送过来的断开请求后，发送TCP报文，其中ACK=1，seq=y,ack=x+1，然后B进入<strong>CLOSE_WAIT</strong>状态，此时B仍然可以向A发送数据。</li>
<li>A接收到B的确认后，进入<strong>FIN_WAIT_2</strong>状态，A仍可接收数据</li>
<li>B数据发送完毕后，发送断开连接请求，发送TCP报文，其中FIN=1，seq=y'，然后B进入<strong>LAST_ACK</strong>状态</li>
<li>A接收到B的断连请求后，发送确认包，其中ACK=1，ack=y'+1，然后A进入<strong>TIME_WAIT</strong>状态，然后B接收到该确认包后关闭连接，进入<strong>CLOSED</strong>状态</li>
<li>A在等待一定时间（两个最大段生命周期 2MSL）后，进入<strong>CLOSED</strong>状态</li>
</ul>

<h3 id="为何是三次握手">为何是三次握手？</h3>

<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论你在消息中包含什么信息，三次通信是理论上的最小值。所以三次握手不是TCP本身的要求, 而是为了满足“在不可靠信道上可靠地传输信息”这一需求所导致的。</p>

<h3 id="为何四次挥手">为何四次挥手？</h3>

<p>因此TCP是全双工通信的，需要双方分别断开连接。第一次挥手表示A数据发送完毕，请求断开连接；第二次挥手表示B同意A断开连接，B仍可向A发送数据，A仍可接收B发送的数据；第三次挥手表示B数据发送完毕，请求断开连接；第四次挥手表示A同意B断开连接。然后A在等待两个最大生命周期后，连接中断，以防B未接收到A发送的确认。</p>

<h3 id="为何timewair等待2msl">为何TIME_WAIR等待2MSL？</h3>

<ul>
<li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li>
<li>防止已失效的连接请求报文段出现在本连接中。TIME_WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li>
</ul>

<h1 id="udp协议">UDP协议</h1>

<h2 id="特点-3">特点</h2>

<ul>
<li>UDP是无连接的，因此减少了开销和发送数据的时延</li>
<li>UDP尽最大努力交付，不保证可靠交付</li>
<li>UDP是面向报文的，发送方的UDP对应用程序交下来的报文在添加首部后就向下交付给IP层，对交下来的报文既不合并也不拆分</li>
<li>UDP没有拥塞控制，保证了实时性</li>
<li>支持一对一，一对多，多对多的通信</li>
<li>UDP首部只有8个字节，开销小</li>
<li>UDP将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。</li>
<li>应用：RIP协议，DNS协议，DHCP协议以及广泛应用在多媒体应用中</li>
</ul>

<h2 id="udp分组结构">UDP分组结构</h2>

<ul>
<li>每个UDP报文分UDP报头和UDP数据区两部分</li>
<li>UDP报头包括4个字段：来源端口号，目的端口号，报文长度，校验和</li>
<li>每个字段占用2个字节（即16个二进制位）</li>
<li>数据报的长度是指包括报头和数据部分在内的总字节数。</li>
</ul>

<h1 id="dns">DNS</h1>

<p>DNS协议就是用来将域名解析到IP地址的一种协议，也可以将IP地址转换为域名。DNS是在名字服务器层次结构中实现的分布式数据库。它是用于客户端和服务器之间的消息交换的应用层协议。DNS协议基于UDP和TCP协议的，端口号53，用户到服务器采用UDP，DNS服务器通信采用TCP。</p>

<h2 id="dns域名结构">DNS域名结构</h2>

<ul>
<li>通用域名：.com，.org，.net</li>
<li>国家域名：.cn，.us</li>
<li>反向域名：IP到域名的映射</li>
</ul>

<h2 id="dns域名服务器">DNS域名服务器</h2>

<ul>
<li><p>根域名服务器</p></li>

<li><p>顶级域名服务器
负责管理所有的二级域名</p></li>

<li><p>权限域名服务器</p></li>

<li><p>本地域名服务器</p></li>
</ul>

<h2 id="地址解析">地址解析</h2>

<h3 id="递归查询">递归查询</h3>

<ul>
<li>当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器</li>
<li>当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找</li>
<li>如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器</li>
<li>根名称服务器包含关于顶级域的至少一个服务器的信息。然后将查询发送到相应的顶级域服务器</li>
<li>如果顶级域名服务器包含映射，则将响应将发送回根服务器，然后发送回主机的本地服务器</li>
<li>若顶级域域名服务器不包含映射，则应包含目的主机的本地DNS服务器的IP地址</li>
<li>目的主机的本地DNS服务器知道目的主机的IP地址，然后将发送回顶级域名服务器，然后发送给根域名服务器，然后发送到主机的本地域名服务器，最后到主机</li>
</ul>

<h3 id="迭代查询">迭代查询</h3>

<ul>
<li>当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器</li>
<li>当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找</li>
<li>如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器</li>
<li>根域DNS服务器将顶级域名服务器发送给本地DNS服务器</li>
<li>然后本地DNS服务器向顶级域名服务器查询，顶级域名服务器将目的主机的IP地址或者目的主机的本地DNS服务器发送给本地DNS服务器</li>
<li>本地DNS服务器向目的主机的本地DNS服务器查询，得到目的主机的IP地址</li>
</ul>

<h1 id="httphttps">HTTP/HTTPS</h1>

<h2 id="两者的不同">两者的不同</h2>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">HTTP</th>
<th align="left">HTTPS</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">地址</td>
<td align="left">http://</td>
<td align="left">https://</td>
</tr>

<tr>
<td align="left">端口</td>
<td align="left">80</td>
<td align="left">443</td>
</tr>

<tr>
<td align="left">安全性</td>
<td align="left">不安全</td>
<td align="left">安全</td>
</tr>

<tr>
<td align="left">加密</td>
<td align="left">未加密，明文传输</td>
<td align="left">加密</td>
</tr>

<tr>
<td align="left">证书</td>
<td align="left">不需要</td>
<td align="left">需要</td>
</tr>
</tbody>
</table>

<h2 id="短连接长连接">短连接/长连接</h2>

<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。</p>

<h3 id="短连接">短连接</h3>

<p>在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。</p>

<h3 id="长连接">长连接</h3>

<p>从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入以下代码：</p>

<pre><code>Connection: keep-alive
</code></pre>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间。</p>

<h2 id="http-请求">HTTP 请求</h2>

<table>
<thead>
<tr>
<th align="left">请求类型</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">GET</td>
<td align="left">请求指定的页面信息，并返回实体主体</td>
</tr>

<tr>
<td align="left">HEAD</td>
<td align="left">类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>

<tr>
<td align="left">PUT</td>
<td align="left">向指定资源位置上传其最新内容</td>
</tr>

<tr>
<td align="left">POST</td>
<td align="left">向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>

<tr>
<td align="left">DELETE</td>
<td align="left">请求服务器删除指定的资源</td>
</tr>

<tr>
<td align="left">CONNECT</td>
<td align="left">HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td>
</tr>

<tr>
<td align="left">OPTIONS</td>
<td align="left">允许客户端查看服务器的性能</td>
</tr>

<tr>
<td align="left">TRACE</td>
<td align="left">回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody>
</table>

<h2 id="http状态码">HTTP状态码</h2>

<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">200</td>
<td align="left">请求成功</td>
</tr>

<tr>
<td align="left">301</td>
<td align="left">资源被永久转移到其他url</td>
</tr>

<tr>
<td align="left">404</td>
<td align="left">请求的资源不存在</td>
</tr>

<tr>
<td align="left">500</td>
<td align="left">内部服务器错误</td>
</tr>
</tbody>
</table>

<h2 id="https-通信过程">HTTPS 通信过程</h2>

<p>HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。</p>

<p>HTTPS在传输的过程中会涉及到三个密钥：</p>

<ul>
<li>服务器端的公钥和私钥，用来进行非对称加密</li>
<li>客户端生成的随机密钥，用来进行对称加密</li>
</ul>

<p>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为以下几步：</p>

<ul>
<li>客户端向服务器发起HTTPS请求，连接到服务器的443端口</li>
<li>服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，服务器将自己的公钥发送给客户端</li>
<li>客户端收到服务器端的公钥之后，验证服务器发送的数字证书的合法性。若合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束</li>
<li>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密</li>
<li>服务器将加密后的密文发送给客户端</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据</li>
</ul>

<h1 id="常见问题">常见问题</h1>

<h2 id="比较ipv4和ipv6">比较IPv4和IPv6</h2>

<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">IPv4</th>
<th align="left">IPv6</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">地址长度</td>
<td align="left">32位</td>
<td align="left">128位</td>
</tr>

<tr>
<td align="left">地址配置</td>
<td align="left">手动，DHCP</td>
<td align="left">自动，重新编号</td>
</tr>

<tr>
<td align="left">地址空间</td>
<td align="left">小</td>
<td align="left">大</td>
</tr>

<tr>
<td align="left">安全性</td>
<td align="left">依赖于应用层</td>
<td align="left">内置安全功能IPSEC</td>
</tr>

<tr>
<td align="left">地址表示</td>
<td align="left">十进制</td>
<td align="left">16进制</td>
</tr>

<tr>
<td align="left">数据包流标识</td>
<td align="left">不可用</td>
<td align="left">可用的，并在标头中使用流标签字段</td>
</tr>

<tr>
<td align="left">校验和</td>
<td align="left">可用</td>
<td align="left">不可用</td>
</tr>

<tr>
<td align="left">加密和身份验证</td>
<td align="left">不提供</td>
<td align="left">提供</td>
</tr>
</tbody>
</table>

<h2 id="请解释主机a是如何向主机b发送一条消息的">请解释主机A是如何向主机B发送一条消息的</h2>

<h3 id="当主机a与主机b在同一个子网中">当主机A与主机B在同一个子网中</h3>

<ul>
<li>构造目的地址为B的IP数据包</li>
<li>根据主机A上的路由表内容，发现目的主机B位于相同子网</li>
<li>查询本地ARP缓存，解析目的MAC地址</li>
<li>若不存在，则发送ARP请求帧广播，网络中每一台主机收到后比对本机MAC地址，若不匹配则丢弃该ARP请求</li>
<li>目的主机B将主机A的IP与MAC映射关系写入ARP缓存，发送向A主机ARP回复消息</li>
<li>当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存</li>

<li><p>将主机B的MAC地址写入数据帧头部，发送该数据帧</p>

<h3 id="主机a与主机b不在同一个子网中">主机A与主机B不在同一个子网中</h3></li>

<li><p>构造目的地址为B的IP数据包</p></li>

<li><p>根据主机A上的路由表内容对该IP数据包进行路由选择：路由选择算法，路由表</p></li>

<li><p>将路由的MAC地址封装到数据帧中发送出去</p></li>

<li><p>路由器接收到该数据帧，发现帧中的目的MAC地址与路由器接收端MAC地址相同，则解封装，上传到网络层</p></li>

<li><p>路由器找到数据包的目的IP地址，并查询路由表，然后将发送到下一个路由</p></li>

<li><p>类似地，直至到达目的主机所在子网，目的主机发现数据帧中的目的MAC与本机网卡MAC地址相同，拆除数据帧封装，上传到网络层</p></li>

<li><p>网络层比较数据包中的目的IP，然后拆除网络成封装，上传到传输层，确认，排序， 重组，然后上交到应用层</p></li>
</ul>

<h2 id="当在浏览器中输入一个url时发生了什么请逐步地尽可能详细的描述">当在浏览器中输入一个url时发生了什么？请逐步地，尽可能详细的描述。</h2>

<h3 id="客户端构建并发送请求">客户端构建并发送请求</h3>

<ol>
<li>应用层域名解析：通过负责域名解析的DNS服务获取网址的IP地址</li>
<li>应用层生成HTTP请求报文</li>
<li>传输层建立TCP连接，DNS使用UDP协议，HTTP使用TCP协议</li>
<li>网络层通过IP协议，OSPF协议进行路由选择</li>
<li>数据链路层实现网络相邻结点间可靠的数据通信</li>
<li>物理层将数据链路层的帧转换成二进制比特流，在物理媒介上进行传输</li>
</ol>

<h3 id="网络传输">网络传输</h3>

<p>传输要经过各种网络设备，交换机，路由器等。</p>

<h4 id="交换机">交换机</h4>

<p>交换机是数据链路层设备，比特流到达交换机，交换机除了对比特流进行放大外，还根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去</p>

<h4 id="路由器">路由器</h4>

<ul>
<li>路由器收到比特流，转换成帧上传到数据链路层，</li>
<li>路由器比较数据帧的目的MAC地址，如果有与路由器接收端口相同的MAC地址，则路由器的数据链路层把数据帧进行解封装，然后上传到路由器的网络层</li>
<li>路由器找到数据包的目的IP地址，并查询路由表，将数据从入端口转发到出端口。</li>
<li>接着在网络层重新封装成数据包packet，下沉到数据链路层重新封装成帧frame，下沉到物理层，转换成二进制比特流，发送出去</li>
</ul>

<h3 id="服务端处理请求返回">服务端处理请求返回</h3>

<ul>
<li>服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层</li>
<li>服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层</li>
<li>服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层</li>
<li>传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性</li>
<li>数据最后被传到服务器的应用层</li>
</ul>

<h3 id="浏览器渲染">浏览器渲染</h3>

<ul>
<li>客户机接受到二进制比特流之后，把比特流转换成帧格式，上传到数据链路层</li>
<li>客户机发现数据帧中的目的MAC地址与本网卡的MAC地址相同，拆除数据链路层的封装后，把数据包上传到网络层</li>
<li>网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，拆除网络层的封装后，把数据分段上传到传输层</li>
<li>传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性</li>
<li>数据最后被传到应用层</li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>13ean </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/>https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://13ean.github.io/tags/network/">
                    #network</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://13ean.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/" class="prev" rel="prev" title="操作系统"><i class="iconfont icon-left"></i>&nbsp;操作系统</a>
         
        
        <a href="https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" class="next" rel="next" title="数据库系统">数据库系统&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
                     <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "13ean" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://13ean.github.io">13ean</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
</footer>












    
    
    <script src="https://13ean.github.io/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
