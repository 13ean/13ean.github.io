<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>interview on 13ean&#39;s Github Page</title>
    <link>https://13ean.github.io/tags/interview/</link>
    <description>Recent content in interview on 13ean&#39;s Github Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Mon, 01 Apr 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://13ean.github.io/tags/interview/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; 知识点总结</title>
      <link>https://13ean.github.io/2019/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>const 定义常量 指针使用const  指针本身是常量：int * const ptr; 指针指向的内容是常量：const int *ptr;或int const *ptr; 指针本身和指针指向内容均为常量：const int * const ptr;  函数使用const  const修饰函数参数 const修饰函数返回值  类中使用const 常成员变量  const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值  常成员函数  const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。 对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用 const成员函数不被允许修改它所在对象的任何一个数据成员 const成员函数能够访问对象的const成员，而其他成员函数不可以  const修饰类对象  const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改 const修饰的对象，该对象的任何非const成员函数都不能被调用  const 常量与宏常量     const 常量 宏常量     处理阶段 编译阶段 预处理阶段进行文本替换   数据类型 有数据类型，编译器可进行类型安全检查 无数据类型，仅进行文本替换   存储方式 在data区分配内存，只有一份拷贝 仅展开，有多少展开多少，因此有多份拷贝   空间占用 只有一份拷贝，节省空间 多份拷贝    static 面向过程的static 静态全局变量  已初始化的在data区中分配内存； 未经初始化的静态全局变量会被初始化为0（而自动变量的值是随机的，除非被显式初始化），存储在bss区 改变了全局变量的链接属性为内部链接，只在该静态全局变量的整个个文件中都可见，而文件之外不可见  静态局部变量  在data区分配内存 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化 它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域  静态函数  将函数的链接属性变为内部链接，只在其声明的文件中可见，其他文件中不可见  面向对象的static 静态数据成员  每个类只有一个拷贝，不属于特定类对象 存储在data区，因此要在定义时分配内存空间，因此不能再类声明中定义 同全局变量相比，使用静态数据成员有两个优势：  静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能   静态成员函数  静态成员函数由于不是与任何的对象相联系，因此它不具有this指针 无法访问类的非静态数据成员和非静态成员函数 出现在类体外的函数定义不能指定关键字static 静态成员函数不能用 const 修饰。因为const成员函数是对该成员函数所具有的 this 指针用 const 来修饰，而静态成员函数不具有 this 指针  sizeof  sizeof计算的是在栈中分配的内存大小 sizeof不计算static变量占的内存 操作数是指针时，返回指针所占内存大小 操作数是数组时，其结果是数组的总字节数 操作数是具体的字符串或数值时，会自动根据其具体类型来进行计算 操作数是联合类型时，sizeof是其最大字节成员的字节数 操作数是结构类型时，sizeof是其成员类型的总字节数，包括补充字节在内 sizeof操作符不能用于函数类型，不完全类型或位字段，不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等 当操作数是一个表达式时，不会对表达式求值  内存对齐  第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为4字节, 则要从4的整数倍地址开始存储)，基本类型不包括struct/class/uinon 结构体作为成员：如果一个结构里有某些结构体成员,则结构体成员要从其内部&amp;quot;最宽基本类型成员&amp;quot;的整数倍地址开始存储 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍 有效对齐值=min{自身对齐值，当前指定的pack值}。  volatile  volatile声明的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等，编译器对访问该变量的代码就不再进行优化 用volatile关键字声明的变量每一次被访问时，执行部件都会从该变量相应的内存单元中取值 没有用volatile关键字声明的变量在被访问的时候可能直接从cpu的寄存器中取值  explicit 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</description>
    </item>
    
    <item>
      <title>数据库系统</title>
      <link>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
      <description>视图 视图是一个虚拟表，其内容由查询定义。视图一经定义便存入数据库中。视图中的数据只是存放在基本表中的数据。
视图作用  简单性：视图可以简化用户的操作 安全性：通过视图用户只能查询和修改他们所看到的数据 逻辑数据独立性：视图可以帮助用户屏蔽真实表结构变化带来的影响  完整性约束 关系完整性约束是为保证数据库中数据的正确性和相容性，对关系模型提出的某种约束条件或规则。完整性通常包括域完整性，实体完整性、参照完整性和用户定义完整性，其中域完整性，实体完整性和参照完整性，是关系模型必须满足的完整性约束条件
 域完整性：保证指定列的数据具有正确的数据类型、格式和有效的数据范围 实体完整性：指关系的主关键字不能重复也不能取“空值”，保证数据库中数据表的每一个特定实体的记录都是唯一的 参照完整性：定义建立关系之间联系的主关键字与外部关键字引用的约束条件。当增加、修改或删除数据库表中记录时，可以借助参照完整性来保证相关联表之间数据的一致性 用户定义完整性：由用户定义的完整性。用户定义完整性可以定义不属于其他任何完整性分类的特定业务规则  索引 可参考：MySQL索引背后的数据结构及算法原理
数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
索引的优点  通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性 可以大大加快数据的检索速度，这也是创建索引的最主要的原因 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能  索引的缺点  创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度  设置索引的原则 应设置索引的情况  较频繁查询的列上创建索引 在经常需要根据范围进行搜索的列上创建索引 在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构 在经常用在连接的列上 在经常需要排序的列上创建索引，因为索引已经排序 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度  不应设置索引的情况  在查询中很少使用或者参考的列不应该创建索引 选择性很差的列，即这些列取值很少 当修改性能远远大于检索性能时，不应该创建索引  索引分类：  唯一索引：唯一索引不允许两行具有相同的索引值 主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空 聚集索引(Clustered)：表中各行的物理顺序与索引顺序相同，每个表只能有一个 非聚集索引(Non-clustered)：非聚集索引指定表中记录的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置指针  索引类型 顺序索引 使用B树或者B+树作为其索引结构
散列索引 哈希索引（hash index）基于哈希表实现。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。对于hash相同的，采用链表的方式解决冲突。
优点：
 访问哈希索引的数据非常快  限制：
 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行 哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序 哈希索引只支持等值比较查询，包括=、IN()、&amp;lt;&amp;gt;，也不支持任何范围查询 当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行  散列索引与顺序索引的区别     Hash索引 顺序索引     实现方式 Hash表 B+树   是否有序 无序 有序   查询方式 只支持点查询 支持点查询和范围查询    存储过程 存储过程是一个预编译的SQL语句。</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>进程管理 进程与线程 进程 进程是程序关于某个数据集合的运行过程，进程是一个活动实体。进程是系统进行资源分配的基本单位。
守护进程 Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。
它们常常在系统引导装入时启动，仅在系统关闭时才终止。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。
用户层守护进程的父进程是 init进程（进程ID为1）。对于用户层守护进程，因为它真正的父进程在 fork 出子进程后就先于子进程 exit 退出了，所以它是一个由 init 继承的孤儿进程。
僵尸进程 在一个进程调用了exit之后，该进程并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。
收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。
孤儿进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
线程 线程是进程中的一个实体，是操作系统进行调度的基本单位，但不是资源分配的基本单位。线程除了必须的PC和寄存器外，几乎不拥有系统资源。
进程与线程的关系  一个进程可以由多个线程组成 进程是资源分配的最小单位，线程是程序执行的最小单位 进程有自己独立的地址空间，同一个进程内的线程共享该进程的所有资源，共享该进程的地址空间。因此线程切换开销较小 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。 每个线程有自己的堆栈和局部变量  协程 协程是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置；
协程的优点：  跨平台，跨体系结构 无需线程上下文切换的开销 无需原子操作锁定及同步的开销，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了 方便切换控制流，简化编程模型 高并发，高扩展  协程的缺点  无法利用多核资源：协程的本质是个单线程 可以通过多进程+协程的方法来利用CPU的多核，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  进程间通信 IPC 管道/匿名管道(pipe)  管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道 只能用于父子进程或者兄弟进程之间 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据  有名管道（FIFO）  允许无亲缘关系进程间的通信  信号量（semaphore）  信号量是一个计数器，用于多进程对共享数据的访问 主要作为进程间以及同一进程不同线程之间的同步手段  共享内存  使得多个进程可以可以直接读写同一块内存空间 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥   消息队列  消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示 消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点  信号  用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身  套接字  更为一般的进程间通信机制，可用于不同机器之间的进程间通信  线程通信 线程通信方式 全局变量  由于多个线程可能更改全局变量，因此全局变量最好声明为volatile  消息传递  每一个线程都可以拥有自己的消息队列  事件  可以通过对事件的触发状态进行改变，从而实现线程间的通信和同步  线程同步方式 线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的通信机制。主要包括互斥锁，读写锁，条件变量。</description>
    </item>
    
  </channel>
</rss>