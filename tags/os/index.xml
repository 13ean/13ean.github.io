<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on 13ean&#39;s Github Page</title>
    <link>https://13ean.github.io/tags/os/</link>
    <description>Recent content in OS on 13ean&#39;s Github Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Sun, 24 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://13ean.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>操作系统</title>
      <link>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>进程管理 进程与线程 进程 进程是程序关于某个数据集合的运行过程，进程是一个活动实体。进程是系统进行资源分配的基本单位。
守护进程 Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。
它们常常在系统引导装入时启动，仅在系统关闭时才终止。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。
用户层守护进程的父进程是 init进程（进程ID为1）。对于用户层守护进程，因为它真正的父进程在 fork 出子进程后就先于子进程 exit 退出了，所以它是一个由 init 继承的孤儿进程。
僵尸进程 在一个进程调用了exit之后，该进程并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。
收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。
孤儿进程 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
线程 线程是进程中的一个实体，是操作系统进行调度的基本单位，但不是资源分配的基本单位。线程除了必须的PC和寄存器外，几乎不拥有系统资源。
进程与线程的关系  一个进程可以由多个线程组成 进程是资源分配的最小单位，线程是程序执行的最小单位 进程有自己独立的地址空间，同一个进程内的线程共享该进程的所有资源，共享该进程的地址空间。因此线程切换开销较小 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。 每个线程有自己的堆栈和局部变量  协程 协程是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置；
协程的优点：  跨平台，跨体系结构 无需线程上下文切换的开销 无需原子操作锁定及同步的开销，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了 方便切换控制流，简化编程模型 高并发，高扩展  协程的缺点  无法利用多核资源：协程的本质是个单线程 可以通过多进程+协程的方法来利用CPU的多核，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。  进程间通信 IPC 管道/匿名管道(pipe)  管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道 只能用于父子进程或者兄弟进程之间 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据  有名管道（FIFO）  允许无亲缘关系进程间的通信  信号量（semaphore）  信号量是一个计数器，用于多进程对共享数据的访问 主要作为进程间以及同一进程不同线程之间的同步手段  共享内存  使得多个进程可以可以直接读写同一块内存空间 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥   消息队列  消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示 消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点  信号  用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身  套接字  更为一般的进程间通信机制，可用于不同机器之间的进程间通信  线程通信 线程通信方式 全局变量  由于多个线程可能更改全局变量，因此全局变量最好声明为volatile  消息传递  每一个线程都可以拥有自己的消息队列  事件  可以通过对事件的触发状态进行改变，从而实现线程间的通信和同步  线程同步方式 线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的通信机制。主要包括互斥锁，读写锁，条件变量。</description>
    </item>
    
  </channel>
</rss>