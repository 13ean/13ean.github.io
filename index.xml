<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>13ean&#39;s Github Page on 13ean&#39;s Github Page</title>
    <link>https://13ean.github.io/</link>
    <description>Recent content in 13ean&#39;s Github Page on 13ean&#39;s Github Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Thu, 28 Mar 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数据库系统</title>
      <link>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;视图&#34;&gt;视图&lt;/h1&gt;

&lt;p&gt;视图是一个虚拟表，其内容由查询定义。视图一经定义便存入数据库中。视图中的数据只是存放在基本表中的数据。&lt;/p&gt;

&lt;h2 id=&#34;视图作用&#34;&gt;视图作用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单性：视图可以简化用户的操作&lt;/li&gt;
&lt;li&gt;安全性：通过视图用户只能查询和修改他们所看到的数据&lt;/li&gt;
&lt;li&gt;逻辑数据独立性：视图可以帮助用户屏蔽真实表结构变化带来的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;完整性约束&#34;&gt;完整性约束&lt;/h1&gt;

&lt;p&gt;关系完整性约束是为保证数据库中数据的正确性和相容性，对关系模型提出的某种约束条件或规则。完整性通常包括域完整性，实体完整性、参照完整性和用户定义完整性，其中域完整性，实体完整性和参照完整性，是关系模型必须满足的完整性约束条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;域完整性：保证指定列的数据具有正确的数据类型、格式和有效的数据范围&lt;/li&gt;
&lt;li&gt;实体完整性：指关系的主关键字不能重复也不能取“空值”，保证数据库中数据表的每一个特定实体的记录都是唯一的&lt;/li&gt;
&lt;li&gt;参照完整性：定义建立关系之间联系的主关键字与外部关键字引用的约束条件。当增加、修改或删除数据库表中记录时，可以借助参照完整性来保证相关联表之间数据的一致性&lt;/li&gt;
&lt;li&gt;用户定义完整性：由用户定义的完整性。用户定义完整性可以定义不属于其他任何完整性分类的特定业务规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;

&lt;p&gt;数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;

&lt;h2 id=&#34;索引的优点&#34;&gt;索引的优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性&lt;/li&gt;
&lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因&lt;/li&gt;
&lt;li&gt;可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义&lt;/li&gt;
&lt;li&gt;在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间&lt;/li&gt;
&lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;索引的缺点&#34;&gt;索引的缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加&lt;/li&gt;
&lt;li&gt;索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大&lt;/li&gt;
&lt;li&gt;当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设置索引的原则&#34;&gt;设置索引的原则&lt;/h2&gt;

&lt;h3 id=&#34;应设置索引的情况&#34;&gt;应设置索引的情况&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;较频繁查询的列上创建索引&lt;/li&gt;
&lt;li&gt;在经常需要根据范围进行搜索的列上创建索引&lt;/li&gt;
&lt;li&gt;在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构&lt;/li&gt;
&lt;li&gt;在经常用在连接的列上&lt;/li&gt;
&lt;li&gt;在经常需要排序的列上创建索引，因为索引已经排序&lt;/li&gt;
&lt;li&gt;在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不应设置索引的情况&#34;&gt;不应设置索引的情况&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在查询中很少使用或者参考的列不应该创建索引&lt;/li&gt;
&lt;li&gt;选择性很差的列，即这些列取值很少&lt;/li&gt;
&lt;li&gt;当修改性能远远大于检索性能时，不应该创建索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;索引分类&#34;&gt;索引分类：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;唯一索引：唯一索引不允许两行具有相同的索引值&lt;/li&gt;
&lt;li&gt;主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空&lt;/li&gt;
&lt;li&gt;聚集索引(Clustered)：表中各行的物理顺序与索引顺序相同，每个表只能有一个&lt;/li&gt;
&lt;li&gt;非聚集索引(Non-clustered)：非聚集索引指定表种记录的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;索引类型&#34;&gt;索引类型&lt;/h3&gt;

&lt;h4 id=&#34;顺序索引&#34;&gt;顺序索引&lt;/h4&gt;

&lt;p&gt;使用B树或者B+树作为其索引结构&lt;/p&gt;

&lt;h4 id=&#34;散列索引&#34;&gt;散列索引&lt;/h4&gt;

&lt;p&gt;哈希索引（hash index）基于哈希表实现。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。对于hash相同的，采用链表的方式解决冲突。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;访问哈希索引的数据非常快&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;限制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行&lt;/li&gt;
&lt;li&gt;哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序&lt;/li&gt;
&lt;li&gt;哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序&lt;/li&gt;
&lt;li&gt;哈希索引只支持等值比较查询，包括=、IN()、&amp;lt;&amp;gt;，也不支持任何范围查询&lt;/li&gt;
&lt;li&gt;当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;散列索引与顺序索引的区别&#34;&gt;散列索引与顺序索引的区别&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Hash索引&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;顺序索引&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;只支持点查询&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支持点查询和范围查询&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;存储过程&#34;&gt;存储过程&lt;/h1&gt;

&lt;p&gt;存储过程是一个预编译的SQL语句。&lt;/p&gt;

&lt;h2 id=&#34;存储过程优点&#34;&gt;存储过程优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;存储过程是预编译过的，执行效率高&lt;/li&gt;
&lt;li&gt;存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯&lt;/li&gt;
&lt;li&gt;安全性高，执行存储过程需要有一定权限的用户&lt;/li&gt;
&lt;li&gt;存储过程可以重复使用，可减少数据库开发人员的工作量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;存储过程缺点&#34;&gt;存储过程缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个数据库的存储过程语法几乎都不一样，十分难以维护&lt;/li&gt;
&lt;li&gt;业务逻辑放在数据库上，难以迭代&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;存储过程和函数的区别&#34;&gt;存储过程和函数的区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;存储过程&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;用途&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用于在数据库中完成特定的操作或者任务&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用于特定的数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;声明&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明用procedure&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明用function&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;返回类型&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明时不需描述返回类型&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明时要描述返回类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;参数模式&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可以使用in/out/in out 三种模式的参数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可以使用in/out/in out 三种模式的参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;能否独立执行&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可作为一个独立的语句来执行&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不能独立执行，必须作为表达式的一部分调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;调用&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SQL语句(DML 或SELECT)中不可调用存储过程&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SQL语句(DML 或SELECT)中可以调用函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;触发器&#34;&gt;触发器&lt;/h2&gt;

&lt;p&gt;触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。&lt;/p&gt;

&lt;h1 id=&#34;join&#34;&gt;join&lt;/h1&gt;

&lt;h2 id=&#34;内连接&#34;&gt;内连接&lt;/h2&gt;

&lt;p&gt;在每个表中找出符合条件的共有记录&lt;/p&gt;

&lt;h2 id=&#34;外连接&#34;&gt;外连接&lt;/h2&gt;

&lt;h3 id=&#34;左连接&#34;&gt;左连接&lt;/h3&gt;

&lt;p&gt;根据左表的记录，在被连接的右表中找出符合条件的记录与之匹配，如果找不到与左表匹配的，用null表示&lt;/p&gt;

&lt;h3 id=&#34;右连接&#34;&gt;右连接&lt;/h3&gt;

&lt;p&gt;根据右表的记录，在被连接的左表中找出符合条件的记录与之匹配，如果找不到匹配的，用null填充&lt;/p&gt;

&lt;h3 id=&#34;全外连接&#34;&gt;全外连接&lt;/h3&gt;

&lt;p&gt;返回左表和右表中的所有记录。若某一行再另一个表中没有与之匹配的，用null表示（结果是左连接和右连接的并集）&lt;/p&gt;

&lt;h2 id=&#34;笛卡尔积交叉连接&#34;&gt;笛卡尔积（交叉连接）&lt;/h2&gt;

&lt;p&gt;将两个表中的每条记录都进行组合。不带WHERE条件子句，它将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积，如果带where，返回或显示的是匹配的行数（先生成笛卡尔积，再根据查询条件进行筛选）。&lt;/p&gt;

&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;

&lt;p&gt;事务是并发控制的基本单元。事务是一个操作序列，由一条或多条SQL语句组成，这些操作要么都执行成功，要么都不执行，它是一个不可分割的工作单位。&lt;/p&gt;

&lt;h2 id=&#34;事务的acid特性&#34;&gt;事务的ACID特性：&lt;/h2&gt;

&lt;h3 id=&#34;原子性atomicity&#34;&gt;原子性（Atomicity）&lt;/h3&gt;

&lt;p&gt;事务是不可分割的工作单位。只有事务中的全部操作执行成功，事务才算执行成功。若任何操作失败，则该事务执行失败，数据库的状态必须回滚到事务开始前的状态。&lt;/p&gt;

&lt;h3 id=&#34;一致性consistency&#34;&gt;一致性（Consistency）&lt;/h3&gt;

&lt;p&gt;事务应保证数据库只能从一个一致状态转移到另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。即事务开始前和结束后数据库数据的完整性没有被破坏。&lt;/p&gt;

&lt;h3 id=&#34;隔离性isolation&#34;&gt;隔离性（Isolation）&lt;/h3&gt;

&lt;p&gt;事务的隔离性要求每个事务的对象和其它事务的操作对象能相互分离。即该事务提交前对其它事务都不可见，这通常使用锁来实现。多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/p&gt;

&lt;h3 id=&#34;持久性durability&#34;&gt;持久性（Durability）&lt;/h3&gt;

&lt;p&gt;事务一旦提交其结果就是永久性的。即数据写入到了数据库中，即使宕机数据也不会丢失。&lt;/p&gt;

&lt;h2 id=&#34;可串行化&#34;&gt;可串行化&lt;/h2&gt;

&lt;p&gt;可串行化指事务并行执行的结果与某个顺序的串行执行结果相同。可串行化&lt;/p&gt;

&lt;h3 id=&#34;先后顺序图串行化图&#34;&gt;先后顺序图/串行化图&lt;/h3&gt;

&lt;p&gt;对于调度S，先后顺序图是一个有向图&lt;span  class=&#34;math&#34;&gt;\(G = (N, E)\)&lt;/span&gt;，由节点集合&lt;span  class=&#34;math&#34;&gt;\(N\)&lt;/span&gt;和有向边集合&lt;span  class=&#34;math&#34;&gt;\(E\)&lt;/span&gt;构成，构建方式如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为每个事务创建一个节点&lt;/li&gt;
&lt;li&gt;如果事务&lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt;读取了&lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt;已经写操作的数据项，创建一条有向边&lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果事务&lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt;对&lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt;已经读取的数据项进行写操作，创建一条有向边&lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果事务&lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt;对&lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt;写操作的数据项进行写操作，创建一条有向边&lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;
如果S的先后顺序图中出现了有向边&lt;span  class=&#34;math&#34;&gt;\(T_i \to T_j\)&lt;/span&gt;，则在任何与之等价的穿行调度&lt;span  class=&#34;math&#34;&gt;\(S&#39;\)&lt;/span&gt;中，&lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt;必须出现在&lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt;的前面。如果先后顺序图中存在环，则该调度不可串行化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数据冲突引起的问题&#34;&gt;数据冲突引起的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;脏读（read uncommitted data）：在&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt;读取了&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;已经修改了的数据&lt;/li&gt;
&lt;li&gt;不可重复读（unreaptable read）：在&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt;修改了&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;已经读取的数据，如果&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;再次读取该数据，则发现不同的值&lt;/li&gt;
&lt;li&gt;更新丢失（overwrite uncommitted data）：在&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt;修改了&lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt;已经写的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;read uncommit 读脏数据&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;unreaptable read 不可重复读&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;overwrite uncommitted 更新丢失&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Read uncommited 读未提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Read committed 读已提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Reaptable read 重复读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Serializable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;乐观与悲观&#34;&gt;乐观与悲观&lt;/h2&gt;

&lt;h3 id=&#34;悲观技术&#34;&gt;悲观技术&lt;/h3&gt;

&lt;h4 id=&#34;加锁方法&#34;&gt;加锁方法&lt;/h4&gt;

&lt;p&gt;加锁是并发事务串行化的常用方法。事务必须在开始影响的数据库读/写操作前获声明一个共享的（读）锁或者专用的（写）锁。如果声明互斥锁，锁禁止其他事务修改甚至读取该数据项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;共享锁：如果事务在一个数据项上加上共享锁，他只能读而不能更新该数据项。&lt;/li&gt;
&lt;li&gt;互斥锁：如果事务在一个数据项上加上互斥锁，他既能读也能更新该数据项。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读操作是不冲突的，因此允许多个并发事务获取数据项的共享锁。另一方面，互斥锁赋予事务对该数据项的独占的访问权限，因此其他事务都无法读取或者更新该数据项。&lt;/p&gt;

&lt;h5 id=&#34;两段锁2pl协议&#34;&gt;两段锁（2PL）协议&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务对一个数据项操作之前，必须先获得对该项的锁&lt;/li&gt;
&lt;li&gt;一旦事务释放了第一个锁，就不能再获得任何新锁&lt;/li&gt;
&lt;li&gt;如果允许对锁进行升级，只能再增长阶段进行，且事务必须等待，知道另一个事务释放了该数据项的共享锁。锁的降级只能再缩减阶段进行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Transaction开始时，对每个需要访问的数据加锁；如果不能加锁，就等待，直到加锁成功&lt;/li&gt;
&lt;li&gt;执行Transaction的内容&lt;/li&gt;
&lt;li&gt;在Transaction commit前，集中进行解锁&lt;/li&gt;
&lt;li&gt;Commit&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;锁的粒度&#34;&gt;锁的粒度&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;意向锁

&lt;ul&gt;
&lt;li&gt;IS(a)：将对a下面更细粒度的数据元素进行读&lt;/li&gt;
&lt;li&gt;IX(a)：将对a下面更细粒度的数据元素进行写&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了得到S，IS：所有祖先必须为IS或IX&lt;/li&gt;
&lt;li&gt;为了得到X，IX：所有祖先必须为IX&lt;/li&gt;
&lt;li&gt;锁兼容性矩阵：&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IS&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IX&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;S&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;X&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;IS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;IX&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;时间戳方法&#34;&gt;时间戳方法&lt;/h4&gt;

&lt;p&gt;在时间戳方法中，较旧的事务（即有较小时间戳的事务），在冲突事件中有较高的优先级。采用时间戳协议，如果一个事务试图读或写一个数据项。只有当该数据项是由一个较旧事务更新时，这次读写才被允许。否则，请求读/写的事务将重新启动，并获得一个新的时间戳。&lt;/p&gt;

&lt;p&gt;每个数据项也有一个读时间戳（其值为最后一个读该数据项事务的时间戳）和一个写时间戳（其值为最后一个写该数据项事务的时间戳）。&lt;/p&gt;

&lt;h5 id=&#34;时间戳排序协议&#34;&gt;时间戳排序协议&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;发出一个读请求 &lt;span  class=&#34;math&#34;&gt;\(read(x)\)&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;反之，若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则读操作继续，并令&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事务T发出一个写请求 write(x)

&lt;ul&gt;
&lt;li&gt;若&lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;若&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;否则，&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) \le T_{timestamp}\)&lt;/span&gt; 且 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则写操作继续，并令&lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;托马斯写规则&#34;&gt;托马斯写规则&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务T发出一个写请求 write(x)

&lt;ul&gt;
&lt;li&gt;若&lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则写操作被忽略&lt;/li&gt;
&lt;li&gt;若&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;否则，&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) \le T_{timestamp}\)&lt;/span&gt; 且 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则写操作继续，并令&lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;乐观技术&#34;&gt;乐观技术&lt;/h3&gt;

&lt;p&gt;乐观技术基于这样一个假设：冲突是罕见的，去除为保证串行化而对事务的延迟，将会更高效。在事务提交时进行检查，若发生冲突，事务必须被回滚。&lt;/p&gt;

&lt;p&gt;事务执行分为三个阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读&lt;/strong&gt;：事务开始执行，读数据到私有工作区，并在私有工作区上完成事务的处理请求，完成修改操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证&lt;/strong&gt;：如果事务决定提交，检查事务是否与其它事务冲突

&lt;ul&gt;
&lt;li&gt;如果存在冲突，那么终止事务，清空私有工作区&lt;/li&gt;
&lt;li&gt;重试事务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写&lt;/strong&gt;：验证通过，没有发现冲突，那么把私有工作区的修改复制到数据库公共数据中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;确认阶段检查事务的读写操作是否发生了冲突。每个事务T开始时分配一个时间戳start(T)，事务的验证阶段分配时间戳validate(T)，事务的结束阶段finish(T)。通过确认检查，需满足以下条件之一：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事务T开始前，所有较旧时间戳的事务S均已完成，即start(T) &amp;lt; finish(S)&lt;/li&gt;
&lt;li&gt;若事务T在一个较旧的事务S结束前开始，则：

&lt;ul&gt;
&lt;li&gt;S所写数据不是当前事务T读取的数据，（保证较旧事务的写不被当前事务读）且&lt;/li&gt;
&lt;li&gt;当前事务T进入验证阶段前，所有较旧事务S已完成其写阶段，即validate(T) &amp;lt; finish(S) &amp;lt; validate(T)。（保证写是串行的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;数据库的恢复&#34;&gt;数据库的恢复&lt;/h1&gt;

&lt;p&gt;采用如下机制进行恢复：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;备份机制：周期地对数据库进行备份&lt;/li&gt;
&lt;li&gt;日志机制：跟踪当前事务的状态与数据库的改变&lt;/li&gt;
&lt;li&gt;检查点机制：数据库与事务日志文件的同步点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wal-写前日志&#34;&gt;WAL 写前日志&lt;/h2&gt;

&lt;h3 id=&#34;日志文件&#34;&gt;日志文件&lt;/h3&gt;

&lt;p&gt;日志文件包括下列数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事务记录

&lt;ul&gt;
&lt;li&gt;事务标识符&lt;/li&gt;
&lt;li&gt;日志记录类型（事务开始，插入，删除，更新，撤销，提交）&lt;/li&gt;
&lt;li&gt;所操作数据项的标识符（更新，插入，删除）&lt;/li&gt;
&lt;li&gt;数据项的前像&lt;/li&gt;
&lt;li&gt;数据项的后像&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;检查点记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果系统发生故障，恢复过程使用日志对事物进行撤销或重做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果“事务开始”和“事务提交”都出现在日志中，使用日志记录来重做，按日志写入更新后字段的后像&lt;/li&gt;
&lt;li&gt;如果“事务开始”出现在日志文件中，但是“事务提交”未出现，则进行撤销，根据日志文件中数据项的前像，是数据库恢复到事务开始前的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;三个范式&#34;&gt;三个范式&lt;/h1&gt;

&lt;h2 id=&#34;第一范式&#34;&gt;第一范式&lt;/h2&gt;

&lt;p&gt;所有属性都是不可分的基本数据项&lt;/p&gt;

&lt;h2 id=&#34;第二范式&#34;&gt;第二范式&lt;/h2&gt;

&lt;p&gt;每个表有且仅有一个数据元素为主键，其他数据元素与主键一一对应&lt;/p&gt;

&lt;h2 id=&#34;第三范式&#34;&gt;第三范式&lt;/h2&gt;

&lt;p&gt;指表中的所有数据元素不但要能唯一地被主键所标识，而且他们之间还必须相互独立，不存在其他的函数关系。&lt;/p&gt;

&lt;h1 id=&#34;nosql&#34;&gt;No-SQL&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络基础</title>
      <link>https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>

&lt;h1 id=&#34;计算机网络模型&#34;&gt;计算机网络模型&lt;/h1&gt;

&lt;h2 id=&#34;osi-七层模型&#34;&gt;OSI 七层模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;物理层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：比特 Bit&lt;/li&gt;
&lt;li&gt;功能作用：确定与传输媒介的接口的一些特性，电气，机械，功能，规程特性&lt;/li&gt;
&lt;li&gt;设备：中继器，集线器&lt;/li&gt;
&lt;li&gt;协议：RJ45等
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据链路层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据链路层可以划分为：逻辑链路控制（LLC）子层和介质访问控制（MAC）子层&lt;/li&gt;
&lt;li&gt;传输单位：帧 Frame&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;链路管理：链路的建立、维持和释放&lt;/li&gt;
&lt;li&gt;帧同步：确定帧的开始与结束&lt;/li&gt;
&lt;li&gt;流量控制：点对点的，即链路层的相邻设备，采用滑动窗口机制&lt;/li&gt;
&lt;li&gt;差错控制：将有差错的物理线路改进为对网络层来说无差错的数据链路，采用奇偶校检码和循环冗余编码（CRC）&lt;/li&gt;
&lt;li&gt;透明传输：使得不论什么样的比特组合都可以在数据链路层传输&lt;/li&gt;
&lt;li&gt;物理寻址：向每个帧的头部加入了源MAC地址和目的MAC地址&lt;/li&gt;
&lt;li&gt;访问控制：当单个线路被多个设备共享时，数据链路层的MAC子层用于帮助确定哪个设备在给定时间控制信道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设备：网桥，交换机&lt;/li&gt;
&lt;li&gt;协议：HDLC协议，PPP协议，ARP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：数据包（分组） Packet&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;路由转发：确定哪条路由适合从源到目的地&lt;/li&gt;
&lt;li&gt;逻辑寻址：向数据包头部加入了目的IP地址和源IP地址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设备：路由器&lt;/li&gt;
&lt;li&gt;协议：IP，ICMP，IGMP，RIP，OSPF，BGP，RARP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传输层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：数据报（报文）Segments&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;提供面向连接的TCP和无连接的UDP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会话层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主要为两个会话层实体进行会话，而进行的对话连接的管理服务。提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点，可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。&lt;/li&gt;
&lt;li&gt;功能作用：对话管理，数据流同步和重新同步&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表示层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;处理两个应用实体之间进行数据交换的语法问题，解决数据交换中存在的语法不一致以及数据表示方法不同等问题&lt;/li&gt;
&lt;li&gt;功能作用：数据编码的转换，数据加密与解密，数据压缩与恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;应用层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接提供文件传输，电子邮件，网页浏览等服务给用户。&lt;/li&gt;
&lt;li&gt;协议：FTP，SMTP，POP3，HTTP，SSH，DNS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tcp-ip模型&#34;&gt;TCP/IP模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;网络接口层&lt;/li&gt;
&lt;li&gt;网际层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;路由算法&#34;&gt;路由算法&lt;/h1&gt;

&lt;h2 id=&#34;内部网关协议-igp&#34;&gt;内部网关协议 IGP&lt;/h2&gt;

&lt;p&gt;用于自治系统内部的路由协议&lt;/p&gt;

&lt;h3 id=&#34;rip协议&#34;&gt;RIP协议&lt;/h3&gt;

&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;基于Bellman-Ford（距离矢量）算法&lt;/li&gt;
&lt;li&gt;RIP使用跳数来衡量距离，每一条链路的成本为1，不考虑带宽，时延等因素&lt;/li&gt;
&lt;li&gt;跳数为&lt;strong&gt;16&lt;/strong&gt;，表示该网络&lt;strong&gt;不可达&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用UDP报文进行路由信息的交换&lt;/li&gt;
&lt;li&gt;RIP路由协议用“更新（UNPDATES）”和“请求（REQUESTS）”这两种分组来传输信息&lt;/li&gt;
&lt;li&gt;每隔30秒向&lt;strong&gt;相邻&lt;/strong&gt;路由器发送一次更新信息，若180秒内未收到某邻居发送的报文，则将该路由置为不可达，若300秒内未接收到，则将其从路由表中删除&lt;/li&gt;
&lt;li&gt;更新信息反映了该路由器所有的路由选择信息数据库，路由选择信息数据库的每个条目由“局域网上能达到的IP地址”和“与该网络的距离”两部分组成&lt;/li&gt;
&lt;li&gt;请求信息用于寻找网络上能发出RIP报文的其他设备&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;慢收敛问题&#34;&gt;慢收敛问题&lt;/h4&gt;

&lt;p&gt;任何距离向量路由选择协议（如RIP）都有一个问题，路由器不知道网络的全局情况，路由器必须依靠相邻路由器来获取网络的可达信息。由于路由选择更新信息在网络上传播慢，距离向量路由选择算法有一个慢收敛问题，这个问题将导致不一致性产生。&lt;/p&gt;

&lt;h4 id=&#34;更新算法&#34;&gt;更新算法&lt;/h4&gt;

&lt;p&gt;假设路由器A，收到了其邻居路由器B发来的更新信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先对更新信息中的所有距离加1&lt;/li&gt;
&lt;li&gt;若A中的路由表没有该网络的路由信息，则加入该网络，下一跳设置为B&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，且下一跳为B，则更新该网络的距离&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，下一跳不为B，且其距离小于当前距离，则更新下一跳为B，更新距离&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，下一跳不为B，且其距离不小于当前距离，则不更新&lt;/li&gt;
&lt;li&gt;对于A中路由表存在的网络，但是更新信息中没有的网络，则不更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ospf协议&#34;&gt;OSPF协议&lt;/h3&gt;

&lt;p&gt;开放最短路径优先（OSPF）是链路状态路由协议，使用Dijkstra算法找到源路由器和目的地路由器之间的最佳路径。链路状态路由协议是使用触发更新的概念的协议。即，如果在学习的路由表中观察到变化，则触发更新，而不像距离矢量路由协议在一段时间内交换。&lt;/p&gt;

&lt;h4 id=&#34;特点-1&#34;&gt;特点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;与大多数路由协议不同（参考BGP和RIP的工作过程），本协议不依赖于传输层协议（如TCP、UDP）提供数据传输、错误检测与恢复服务，数据包直接封装在IP协议（协议号89）内传输&lt;/li&gt;
&lt;li&gt;使用Dijkstra算法计算出到达每一网络的最短路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;外部网关协议-egp&#34;&gt;外部网关协议 EGP&lt;/h2&gt;

&lt;p&gt;用于自治系统间接口上的路由协议&lt;/p&gt;

&lt;h3 id=&#34;bgp协议&#34;&gt;BGP协议&lt;/h3&gt;

&lt;p&gt;BGP用于在不同的自治系统（AS）之间交换路由信息，运行在TCP协议之上。当两个AS需要交换路由信息时，每个AS都必须指定一个运行BGP的节点，来代表AS与其他的AS交换路由信息。这个节点可以是一个主机。但通常是路由器来执行BGP。两个AS中利用BGP交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）。&lt;/p&gt;

&lt;h1 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h1&gt;

&lt;h2 id=&#34;特点-2&#34;&gt;特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TCP是面向连接的，在传输数据之前必须先建立连接，传输完毕后释放连接&lt;/li&gt;
&lt;li&gt;TCP只支持点对点通信&lt;/li&gt;
&lt;li&gt;TCP提供可靠交付，保证数据无差错，不丢失，无重复，有序到达&lt;/li&gt;
&lt;li&gt;TCP提供全双工通信，双方都可以发送和接收数据&lt;/li&gt;
&lt;li&gt;面向字节流&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp可靠传输&#34;&gt;TCP可靠传输&lt;/h2&gt;

&lt;h3 id=&#34;差错控制&#34;&gt;差错控制：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;校验和：每个TCP报文段都包括检验和字段，校验和用来检查报文段是否出现传输错误，如果报文段出现传输错误，TCP检查出错就丢弃该报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;编号与确认&#34;&gt;编号与确认&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;TCP为报文编号，以实现报文的有序接收&lt;/li&gt;
&lt;li&gt;接收端检查报文是否出错，发现出错时就丢弃，不发确认；而发送端通过检查接收端的确认，判断发送的报文段是否已经正确到达目的地&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;超时重传&#34;&gt;超时重传&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;发送端根据发出的报文段在规定的时间内是否收到确认，从而来判断该报文段是否丢失或传输出错。超过一定时间未收到确认，则重新发送该报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp流量控制与拥塞控制&#34;&gt;TCP流量控制与拥塞控制&lt;/h2&gt;

&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;停止等待协议：发送窗口swnd=1，接收窗口rwnd=1

&lt;ul&gt;
&lt;li&gt;发送方每发送一个报文，则直到接收到接收方的确认报文才发送下一个报文&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后退N协议：发送窗口swnd&amp;gt;1，接受窗口rwnd=1

&lt;ul&gt;
&lt;li&gt;发送方可以连续发送发送窗口内的报文，每当接收到一个错误帧，则需要重传该帧及之后的所有帧&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择重传协议：发送窗口swnd&amp;gt;1，接收窗口rwnd&amp;gt;1

&lt;ul&gt;
&lt;li&gt;只重传错误帧即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;慢启动与拥塞避免&#34;&gt;慢启动与拥塞避免&lt;/h3&gt;

&lt;h4 id=&#34;慢启动算法&#34;&gt;慢启动算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;初始时，设置拥塞窗口cwnd=1，表示可以传输一个最大的报文段MSS的数据，设置慢启动门限初值ssthresh&lt;/li&gt;
&lt;li&gt;当cwnd &amp;lt; ssthresh 时，每收到新报文的ACK，则拥塞窗口cwnd++，因此每过一个RTT，则cwnd*2，呈指数增长&lt;/li&gt;
&lt;li&gt;当cwnd &amp;gt;= ssthresh 时，改用拥塞避免算法
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;拥塞避免算法&#34;&gt;拥塞避免算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当 cwdn &amp;gt;= ssthresh 时，每过一个RTT，拥塞窗口cwnd++&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;超时重传-拥塞发生&#34;&gt;超时重传（拥塞发生）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将ssthresh置为拥塞发生时拥塞窗口cwnd大小的一半&lt;/li&gt;
&lt;li&gt;拥塞窗口cwnd大小置为1，改用慢启动算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;快重传与快恢复&#34;&gt;快重传与快恢复&lt;/h3&gt;

&lt;h4 id=&#34;快重传&#34;&gt;快重传&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每当发送端接收到三个重复确认帧时，则直接开启重传，而不等待RTO超时&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;快恢复&#34;&gt;快恢复&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;重新将慢开始门限ssthresh设置为拥塞窗口cwnd的一半&lt;/li&gt;
&lt;li&gt;将拥塞窗口cwnd设置为ssthresh，然后采用拥塞避免算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;流量控制和拥塞控制的区别&#34;&gt;流量控制和拥塞控制的区别：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;流量控制是针对点对点的通信量的控制，是端到端的问题。流量控制所作的就是控制发送端的发送速率，以使得接收端能够接收。&lt;/li&gt;
&lt;li&gt;而拥塞控制是止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp连接管理&#34;&gt;TCP连接管理&lt;/h2&gt;

&lt;h3 id=&#34;tcp的建立过程&#34;&gt;TCP的建立过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;首先client发送连接请求，发送TCP报文，其中SYN=1， seq=x，然后clien进入SYN_SEND状态&lt;/li&gt;
&lt;li&gt;server接收到连接请求，发送TCP报文，进行确认，其中SYN=1，ACK=1，seq=y，ack=x+1，然后server进入SYN_RCVD状态&lt;/li&gt;
&lt;li&gt;clieten收到server发送过来的报文后，进行确认，其中ACK=1，seq=x+1，ack=y+1，然后client进入ESTABLISHED状态，server接收到该报文后也进入ESTABLISHED状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tcp释放连接过程&#34;&gt;TCP释放连接过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A发送断开连接请求，发送TCP报文，其中FIN=1，seq=x，然后A进入FIN_WAIT_1状态&lt;/li&gt;
&lt;li&gt;B接收到A发送过来的断开请求后，发送TCP报文，其中ACK=1，seq=y,ack=x+1，然后B进入CLOSE_WAIT状态，此时B仍然可以向发起者发送数据&lt;/li&gt;
&lt;li&gt;B数据发送完毕后，发送断开连接请求，发送TCP报文，其中FIN=1，seq=y&amp;rsquo;，然后B进入LAST_ACK状态&lt;/li&gt;
&lt;li&gt;A接收到B的断连请求后，发送确认包，其中ACK=1，ack=y&amp;rsquo;+1，然后A进入TIME_WAIR状态，然后B接收到该确认包后关闭连接，进入CLOSED状态&lt;/li&gt;
&lt;li&gt;A在等待一定时间（两个最大段生命周期 2MSL）后，进入CLOSED状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;为何是三次握手&#34;&gt;为何是三次握手？&lt;/h3&gt;

&lt;p&gt;为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足&amp;rdquo;在不可靠信道上可靠地传输信息&amp;rdquo;这一需求所导致的。&lt;/p&gt;

&lt;h3 id=&#34;为何四次挥手&#34;&gt;为何四次挥手？&lt;/h3&gt;

&lt;p&gt;因此TCP是全双工通信的，需要双方分别断开连接。第一次挥手表示A数据发送完毕，请求断开连接；第二次挥手表示B同意A断开连接，B仍可向A发送数据，A仍可接收B发送的数据；第三次挥手表示B数据发送完毕，请求断开连接；第四次挥手表示A同意B断开连接。然后A在等待两个最大生命周期后，连接中断，以防B未接收到A发送的确认。&lt;/p&gt;

&lt;h1 id=&#34;udp协议&#34;&gt;UDP协议&lt;/h1&gt;

&lt;h2 id=&#34;特点-3&#34;&gt;特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;UDP是无连接的，因此减少了开销和发送数据的时延&lt;/li&gt;
&lt;li&gt;UDP尽最大努力交付，不保证可靠交付&lt;/li&gt;
&lt;li&gt;UDP是面向报文的，发送方的UDP对应用程序交下来的报文在添加首部后就向下交付给IP层，对交下来的报文既不合并也不拆分&lt;/li&gt;
&lt;li&gt;UDP没有拥塞控制，保证了实时性&lt;/li&gt;
&lt;li&gt;支持一对一，一对多，多对多的通信&lt;/li&gt;
&lt;li&gt;UDP首部只有8个字节，开销小&lt;/li&gt;
&lt;li&gt;UDP将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。&lt;/li&gt;
&lt;li&gt;应用：RIP协议，DNS协议，DHCP协议以及广泛应用在多媒体应用中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;udp分组结构&#34;&gt;UDP分组结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个UDP报文分UDP报头和UDP数据区两部分&lt;/li&gt;
&lt;li&gt;UDP报头包括4个字段：来源端口号，目的端口号，报文长度，校验和&lt;/li&gt;
&lt;li&gt;每个字段占用2个字节（即16个二进制位）&lt;/li&gt;
&lt;li&gt;数据报的长度是指包括报头和数据部分在内的总字节数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;

&lt;p&gt;DNS协议就是用来将域名解析到IP地址的一种协议，也可以将IP地址转换为域名。DNS是在名字服务器层次结构中实现的分布式数据库。它是用于客户端和服务器之间的消息交换的应用层协议。DNS协议基于UDP和TCP协议的，端口号53，用户到服务器采用UDP，DNS服务器通信采用TCP。&lt;/p&gt;

&lt;h2 id=&#34;dns域名结构&#34;&gt;DNS域名结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通用域名：.com，.org，.net&lt;/li&gt;
&lt;li&gt;国家域名：.cn，.us&lt;/li&gt;
&lt;li&gt;反向域名：IP到域名的映射&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns域名服务器&#34;&gt;DNS域名服务器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根域名服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;顶级域名服务器
负责管理所有的二级域名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;权限域名服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地域名服务器&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;地址解析&#34;&gt;地址解析&lt;/h2&gt;

&lt;h3 id=&#34;递归查询&#34;&gt;递归查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器&lt;/li&gt;
&lt;li&gt;当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找&lt;/li&gt;
&lt;li&gt;如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器&lt;/li&gt;
&lt;li&gt;根名称服务器包含关于顶级域的至少一个服务器的信息。然后将查询发送到相应的顶级域服务器。&lt;/li&gt;
&lt;li&gt;如果顶级域名服务器包含映射，则将响应将发送回根服务器，然后发送回主机的本地服务器。&lt;/li&gt;
&lt;li&gt;若顶级域域名服务器不包含映射，则应包含目的主机的本地DNS服务器的IP地址&lt;/li&gt;
&lt;li&gt;目的主机的本地DNS服务器知道目的主机的IP地址，然后将发送回顶级域名服务器，然后发送给根域名服务器，然后发送到主机的本地域名服务器，最后到主机&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;迭代查询&#34;&gt;迭代查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器&lt;/li&gt;
&lt;li&gt;当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找&lt;/li&gt;
&lt;li&gt;如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器&lt;/li&gt;
&lt;li&gt;根域DNS服务器将顶级域名服务器发送给本地DNS服务器&lt;/li&gt;
&lt;li&gt;然后本地DNS服务器向顶级域名服务器查询，顶级域名服务器将目的主机的IP地址或者目的主机的本地DNS服务器发送给本地DNS服务器&lt;/li&gt;
&lt;li&gt;本地DNS服务器向目的主机的本地DNS服务器查询，得到目的主机的IP地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;http-https&#34;&gt;HTTP/HTTPS&lt;/h1&gt;

&lt;h2 id=&#34;两者的不同&#34;&gt;两者的不同&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;HTTP&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;HTTPS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;http://&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;https://&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端口&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;443&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;安全性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不安全&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;安全&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;网络层级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;工作在应用层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;工作在传输层&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;未加密，明文传输&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;加密&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;证书&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不需要&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;常见问题&#34;&gt;常见问题&lt;/h1&gt;

&lt;h2 id=&#34;比较ipv4和ipv6&#34;&gt;比较IPv4和IPv6&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IPv4&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IPv6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址长度&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32位&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址配置&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;手动，DHCP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自动，重新编号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;大&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;安全性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;依赖于应用层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内置安全功能IPSEC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址表示&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;十进制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16进制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;数据包流标识&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可用的，并在标头中使用流标签字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;校验和&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;加密和身份验证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不提供&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;提供&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;请解释主机a是如何向主机b发送一条消息的&#34;&gt;请解释主机A是如何向主机B发送一条消息的&lt;/h2&gt;

&lt;h3 id=&#34;当主机a与主机b在同一个子网中&#34;&gt;当主机A与主机B在同一个子网中&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;构造目的地址为B的IP数据包&lt;/li&gt;
&lt;li&gt;根据主机A上的路由表内容，发现目的主机B位于相同子网&lt;/li&gt;
&lt;li&gt;查询本地ARP缓存，解析目的MAC地址&lt;/li&gt;
&lt;li&gt;若不存在，则发送ARP请求帧广播，网络中每一台主机收到后比对本机MAC地址，若不匹配则丢弃该ARP请求&lt;/li&gt;
&lt;li&gt;目的主机B将主机A的IP与MAC映射关系写入ARP缓存，发送向A主机ARP回复消息&lt;/li&gt;
&lt;li&gt;当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将主机B的MAC地址写入数据帧头部，发送该数据帧&lt;/p&gt;

&lt;h3 id=&#34;主机a与主机b不在同一个子网中&#34;&gt;主机A与主机B不在同一个子网中&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造目的地址为B的IP数据包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据主机A上的路由表内容对该IP数据包进行路由选择：路由选择算法，路由表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将路由的MAC地址封装到数据帧中发送出去&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;路由器接收到该数据帧，发现帧中的目的MAC地址与路由器接收端MAC地址相同，则解封装，上传到网络层&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;路由器找到数据包的目的IP地址，并查询路由表，然后将发送到下一个路由&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似地，直至到达目的主机所在子网，目的主机发现数据帧中的目的MAC与本机网卡MAC地址相同，拆除数据帧封装，上传到网络层&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络层比较数据包中的目的IP，然后拆除网络成封装，上传到传输层，确认，排序， 重组，然后上交到应用层&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;当在浏览器中输入一个url时发生了什么-请逐步地-尽可能详细的描述&#34;&gt;当在浏览器中输入一个url时发生了什么？请逐步地，尽可能详细的描述。&lt;/h2&gt;

&lt;h3 id=&#34;客户端构建并发送请求&#34;&gt;客户端构建并发送请求&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;应用层域名解析：通过负责域名解析的DNS服务获取网址的IP地址&lt;/li&gt;
&lt;li&gt;应用层生成HTTP请求报文&lt;/li&gt;
&lt;li&gt;传输层建立TCP连接，DNS使用UDP协议，HTTP使用TCP协议&lt;/li&gt;
&lt;li&gt;网络层通过IP协议，OSPF协议进行路由选择&lt;/li&gt;
&lt;li&gt;数据链路层实现网络相邻结点间可靠的数据通信&lt;/li&gt;
&lt;li&gt;物理层将数据链路层的帧转换成二进制比特流，在物理媒介上进行传输&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;网络传输&#34;&gt;网络传输&lt;/h3&gt;

&lt;p&gt;传输要经过各种网络设备，交换机，路由器等。&lt;/p&gt;

&lt;h4 id=&#34;交换机&#34;&gt;交换机&lt;/h4&gt;

&lt;p&gt;交换机是数据链路层设备，比特流到达交换机，交换机除了对比特流进行放大外，还根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去&lt;/p&gt;

&lt;h4 id=&#34;路由器&#34;&gt;路由器&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;路由器收到比特流，转换成帧上传到数据链路层，&lt;/li&gt;
&lt;li&gt;路由器比较数据帧的目的MAC地址，如果有与路由器接收端口相同的MAC地址，则路由器的数据链路层把数据帧进行解封装，然后上传到路由器的网络层&lt;/li&gt;
&lt;li&gt;路由器找到数据包的目的IP地址，并查询路由表，将数据从入端口转发到出端口。&lt;/li&gt;
&lt;li&gt;接着在网络层重新封装成数据包packet，下沉到数据链路层重新封装成帧frame，下沉到物理层，转换成二进制比特流，发送出去&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务端处理请求返回&#34;&gt;服务端处理请求返回&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层&lt;/li&gt;
&lt;li&gt;服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层&lt;/li&gt;
&lt;li&gt;服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层&lt;/li&gt;
&lt;li&gt;传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性&lt;/li&gt;
&lt;li&gt;数据最后被传到服务器的应用层&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;浏览器渲染&#34;&gt;浏览器渲染&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;客户机接受到二进制比特流之后，把比特流转换成帧格式，上传到数据链路层&lt;/li&gt;
&lt;li&gt;客户机发现数据帧中的目的MAC地址与本网卡的MAC地址相同，拆除数据链路层的封装后，把数据包上传到网络层&lt;/li&gt;
&lt;li&gt;网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，拆除网络层的封装后，把数据分段上传到传输层&lt;/li&gt;
&lt;li&gt;传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性&lt;/li&gt;
&lt;li&gt;数据最后被传到应用层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://13ean.github.io/about/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/about/</guid>
      <description>&lt;p&gt;该Blog用于记录13ean的生活以及学习的点点滴滴。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>