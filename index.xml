<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>13ean&#39;s Github Page on 13ean&#39;s Github Page</title>
    <link>https://13ean.github.io/</link>
    <description>Recent content in 13ean&#39;s Github Page on 13ean&#39;s Github Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>All rights reserved - 2019</copyright>
    <lastBuildDate>Mon, 01 Apr 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C&#43;&#43; 知识点总结</title>
      <link>https://13ean.github.io/2019/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;h1 id=&#34;const&#34;&gt;const&lt;/h1&gt;

&lt;h2 id=&#34;定义常量&#34;&gt;定义常量&lt;/h2&gt;

&lt;h2 id=&#34;指针使用const&#34;&gt;指针使用const&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;指针本身是常量：&lt;code&gt;int * const ptr;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针指向的内容是常量：&lt;code&gt;const int *ptr;&lt;/code&gt;或&lt;code&gt;int const *ptr;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针本身和指针指向内容均为常量：&lt;code&gt;const int * const ptr;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;函数使用const&#34;&gt;函数使用const&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰函数参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰函数返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;类中使用const&#34;&gt;类中使用const&lt;/h2&gt;

&lt;h3 id=&#34;常成员变量&#34;&gt;常成员变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常成员函数&#34;&gt;常成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰类的成员函数，则该成员函数不能修改类中任何非&lt;code&gt;const&lt;/code&gt;成员函数。一般写在函数的最后来修饰。&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;const&lt;/code&gt;类对象/指针/引用，只能调用类的&lt;code&gt;const&lt;/code&gt;成员函数，因此，&lt;code&gt;const&lt;/code&gt;修饰成员函数的最重要作用就是限制对于&lt;code&gt;const&lt;/code&gt;对象的使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;成员函数不被允许修改它所在对象的任何一个数据成员&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;成员函数能够访问对象的&lt;code&gt;const&lt;/code&gt;成员，而其他成员函数不可以&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;const修饰类对象&#34;&gt;const修饰类对象&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;修饰的对象，该对象的任何非&lt;code&gt;const&lt;/code&gt;成员函数都不能被调用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;const-常量与宏常量&#34;&gt;const 常量与宏常量&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;const 常量&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;宏常量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;处理阶段&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;编译阶段&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;预处理阶段进行文本替换&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;数据类型&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;有数据类型，编译器可进行类型安全检查&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无数据类型，仅进行文本替换&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;存储方式&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;在data区分配内存，只有一份拷贝&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;仅展开，有多少展开多少，因此有多份拷贝&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;空间占用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;只有一份拷贝，节省空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;多份拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;static&#34;&gt;static&lt;/h1&gt;

&lt;h2 id=&#34;面向过程的static&#34;&gt;面向过程的static&lt;/h2&gt;

&lt;h3 id=&#34;静态全局变量&#34;&gt;静态全局变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;已初始化的在data区中分配内存；&lt;/li&gt;
&lt;li&gt;未经初始化的静态全局变量会被初始化为0（而自动变量的值是随机的，除非被显式初始化），存储在bss区&lt;/li&gt;
&lt;li&gt;改变了全局变量的链接属性为内部链接，只在该静态全局变量的整个个文件中都可见，而文件之外不可见&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;静态局部变量&#34;&gt;静态局部变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在data区分配内存&lt;/li&gt;
&lt;li&gt;静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化&lt;/li&gt;
&lt;li&gt;它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;静态函数&#34;&gt;静态函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将函数的链接属性变为内部链接，只在其声明的文件中可见，其他文件中不可见&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;面向对象的static&#34;&gt;面向对象的static&lt;/h2&gt;

&lt;h3 id=&#34;静态数据成员&#34;&gt;静态数据成员&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个类只有一个拷贝，不属于特定类对象&lt;/li&gt;
&lt;li&gt;存储在data区，因此要在定义时分配内存空间，因此不能再类声明中定义&lt;/li&gt;
&lt;li&gt;同全局变量相比，使用静态数据成员有两个优势：

&lt;ul&gt;
&lt;li&gt;静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性&lt;/li&gt;
&lt;li&gt;可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;静态成员函数&#34;&gt;静态成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;静态成员函数由于不是与任何的对象相联系，因此它不具有this指针&lt;/li&gt;
&lt;li&gt;无法访问类的非静态数据成员和非静态成员函数&lt;/li&gt;
&lt;li&gt;出现在类体外的函数定义不能指定关键字&lt;code&gt;static&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;静态成员函数不能用 &lt;code&gt;const&lt;/code&gt; 修饰。因为&lt;code&gt;const&lt;/code&gt;成员函数是对该成员函数所具有的 &lt;code&gt;this&lt;/code&gt; 指针用 &lt;code&gt;const&lt;/code&gt; 来修饰，而静态成员函数不具有 &lt;code&gt;this&lt;/code&gt; 指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sizeof&#34;&gt;sizeof&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;sizeof计算的是在栈中分配的内存大小&lt;/li&gt;
&lt;li&gt;sizeof不计算static变量占的内存&lt;/li&gt;
&lt;li&gt;操作数是指针时，返回指针所占内存大小&lt;/li&gt;
&lt;li&gt;操作数是数组时，其结果是数组的总字节数&lt;/li&gt;
&lt;li&gt;操作数是具体的字符串或数值时，会自动根据其具体类型来进行计算&lt;/li&gt;
&lt;li&gt;操作数是联合类型时，&lt;code&gt;sizeof&lt;/code&gt;是其最大字节成员的字节数&lt;/li&gt;
&lt;li&gt;操作数是结构类型时，&lt;code&gt;sizeof&lt;/code&gt;是其成员类型的总字节数，包括补充字节在内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;操作符不能用于函数类型，不完全类型或位字段，不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、&lt;code&gt;void&lt;/code&gt;类型等&lt;/li&gt;
&lt;li&gt;当操作数是一个表达式时，不会对表达式求值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为4字节, 则要从4的整数倍地址开始存储)，基本类型不包括struct/class/uinon&lt;/li&gt;
&lt;li&gt;结构体作为成员：如果一个结构里有某些结构体成员,则结构体成员要从其内部&amp;quot;最宽基本类型成员&amp;quot;的整数倍地址开始存储&lt;/li&gt;
&lt;li&gt;结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍&lt;/li&gt;
&lt;li&gt;有效对齐值=min{自身对齐值，当前指定的pack值}。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;volatile&#34;&gt;volatile&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt;声明的变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等，编译器对访问该变量的代码就不再进行优化&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;volatile&lt;/code&gt;关键字声明的变量每一次被访问时，执行部件都会从该变量相应的内存单元中取值&lt;/li&gt;
&lt;li&gt;没有用&lt;code&gt;volatile&lt;/code&gt;关键字声明的变量在被访问的时候可能直接从cpu的寄存器中取值&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;explicit&#34;&gt;explicit&lt;/h1&gt;

&lt;p&gt;在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;explicit 关键字只能用于类内部的构造函数声明上&lt;/li&gt;
&lt;li&gt;explicit 关键字作用于单个参数的构造函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;指针与数组&#34;&gt;指针与数组&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;数组要么在全局数据区被创建，要么在栈上被创建；指针可以随时指向任意类型的内存块&lt;/li&gt;
&lt;li&gt;运算符sizeof可以计算出数组的容量（字节数；对于指针得到的是一个指针变量的字节数，而不是p所指的内存容量&lt;/li&gt;
&lt;li&gt;当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;指针数组和数组指针&#34;&gt;指针数组和数组指针&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;指针数组是一个数组，数组中存放的数据类型是指针&lt;/li&gt;
&lt;li&gt;数组指针是一个指针，该指针指向数组&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int *p1[4]; // 指针数组，p1中的元素为int型指针
int (*p2)[4]; // 数组指针，p2指向包含4个int型数据的数组
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;的优先级高于&lt;code&gt;*&lt;/code&gt;，因此p1为数组名，数组中存储的内容是int型指针&lt;/li&gt;
&lt;li&gt;p2是一个指针，数组中的元素为int型，p2指向一个包含int型数据的数组&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;引用&#34;&gt;引用&lt;/h1&gt;

&lt;h2 id=&#34;引用作为函数返回值&#34;&gt;引用作为函数返回值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在内存中不产生被返回值的副本&lt;/li&gt;
&lt;li&gt;不能返回局部变量的引用&lt;/li&gt;
&lt;li&gt;不能返回函数内部new分配的内存的引用&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;右值引用&#34;&gt;右值引用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在C++中可以取地址的，有名字的为左值；没名字的，不能取地址的，称右值。&lt;/li&gt;
&lt;li&gt;右值分为两种：

&lt;ul&gt;
&lt;li&gt;将亡值：将要被移动的对象，如返回右值引用&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;的函数的返回值，&lt;code&gt;std::move()&lt;/code&gt;的返回值，或者转换为&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;的类型转换函数的返回值。&lt;/li&gt;
&lt;li&gt;纯右值：非引用返回的临时变量，以及不和对象关联的字面值，类型转换函数的返回值，lambda表达式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::move()&lt;/code&gt;能将左值强转为右值，继而可以通过右值引用来使用这个值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;a href=&#34;https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html&#34;&gt;右值引用与转移语义&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;指针与引用&#34;&gt;指针与引用&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;指针&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;引用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;一个变量，存储的是一个地址&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;别名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;需解引用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;无需解引用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;指针可以为空&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用不能为空&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;指针可以有多级&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用只能一级&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;指针初始化后可以改变&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用初始化后不能改变&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;sizeof指针得到的是指针本身的大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;sizeof引用得到的是所指对象的大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;指针自增相当于地址自增&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;引用自增相当于所指变量自增&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;使用场景&#34;&gt;使用场景&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;存在不指向任何对象的可能时，应该使用&lt;strong&gt;指针&lt;/strong&gt;（在这种情况下，你能够设置指针为空）&lt;/li&gt;
&lt;li&gt;能够在不同的时刻指向不同的对象时，应该使用&lt;strong&gt;指针&lt;/strong&gt;（在这种情况下，你能改变指针的指向）&lt;/li&gt;
&lt;li&gt;如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么应该使用&lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当重载某个操作符时，应该使用&lt;strong&gt;引用&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;newdeletemallocfree&#34;&gt;new/delete、malloc/free&lt;/h1&gt;

&lt;h2 id=&#34;newdelete&#34;&gt;new/delete&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;new 有两种形式的new，一种是生成一个对象的&lt;code&gt;operator new&lt;/code&gt;，另一个是用于数组的&lt;code&gt;operator new []&lt;/code&gt;。同时delete也分普通版本的&lt;code&gt;operator delete&lt;/code&gt; 以及数组版的&lt;code&gt;operator delete[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator new[]&lt;/code&gt;会调用&lt;code&gt;malloc()&lt;/code&gt;分配4个字节大小+数组大小的内存空间，其中4个字节的内存空间用来存储数组的大小，然后循环调用构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;operator delete[]&lt;/code&gt;首先读取数组大小，然后循环调用析构函数，再执行&lt;code&gt;free()&lt;/code&gt;函数，其中传入的地址是偏移后的地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;mallocfree&#34;&gt;malloc/free&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;堆内存空间通过内存块的形式组织起来，&lt;/li&gt;
&lt;li&gt;内存块的大致结构：每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址&lt;/li&gt;
&lt;li&gt;寻找合适的内存块，通常有如下算法：

&lt;ul&gt;
&lt;li&gt;最佳适应（best fit）&lt;/li&gt;
&lt;li&gt;最先适应（first fit）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block&lt;/li&gt;
&lt;li&gt;free时，首先验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址&lt;/li&gt;
&lt;li&gt;解决碎片问题：当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;new/delete&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;malloc/free&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C++ 运算符&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C/C++ 库函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;类型安全&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;类型安全的&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不是类型安全的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;返回值&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;特定类型的指针&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;void*&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;数组&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;new[]/delete[]&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;手动计算&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;重新分配大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可通过realloc改变大小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;失败&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;抛出异常&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;返回空指针&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;空间大小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;编译器自动计算&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需指定字节数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;使用构造/析构函数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;使用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不使用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;重载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可重载&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可重载&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;inline-内联函数&#34;&gt;inline 内联函数&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;关键字&lt;code&gt;inline&lt;/code&gt; 必须与函数定义体放在一起才能使函数成为内联，仅将&lt;code&gt;inline&lt;/code&gt;放在函数声明前面不起任何作用&lt;/li&gt;
&lt;li&gt;inline只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是递归函数&lt;/li&gt;
&lt;li&gt;内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。&lt;/li&gt;
&lt;li&gt;在类内部定义的函数会默认声明为&lt;code&gt;inline&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;虚函数不允许内联&lt;/li&gt;
&lt;li&gt;对于普通函数&lt;code&gt;g()&lt;/code&gt;，如果接口与实现都在头文件中B.h中，如果B.h被多个.cpp源文件包含，那么链接时将会发生函数&lt;code&gt;g()&lt;/code&gt;重复定义的错误。此时可将函数&lt;code&gt;g()&lt;/code&gt;设置为inline, 便可消除错误&lt;/li&gt;
&lt;li&gt;对于类的成员方法，一般也是要求接口与实现分离，将成员方法的实现放到 .cpp文件中；如果在头文件的类内部给出实现，也可以编译通过（不是好的习惯），因为类内部自带&lt;code&gt;inline&lt;/code&gt;。如果在头文件的类外给出成员方法的定义，必须显示的设为&lt;code&gt;inline&lt;/code&gt;，否则也会发生重复定义的错误。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内联函数与宏&#34;&gt;内联函数与宏&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;内联函数&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;宏&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;类型检查&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;执行类型检查&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不执行类型检查&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;展开&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内联只是一种建议，编译器是否采用内联措施由编译器自己来决定&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;强制的内联展开&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;struct-与-class&#34;&gt;struct 与 class&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;struct&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;class&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;默认成员属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;public&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;private&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;默认继承属性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;public&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;private&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;虚继承&#34;&gt;虚继承&lt;/h1&gt;

&lt;p&gt;假如类A和类B各自从类X派生（非虚继承且假设类X包含一些数据成员），且类C同时多继承自类A和B，那么C的对象就会拥有两套X的实例数据（可分别独立访问，一般要用适当的消歧义限定符）。但是如果类A与B各自虚继承了类X，那么C的对象就只包含一套类X的实例数据。可以使得虚基类对于由它直接或间接派生的类来说，拥有一个共同的基类对象实例。&lt;/p&gt;

&lt;h2 id=&#34;实现原理&#34;&gt;实现原理&lt;/h2&gt;

&lt;p&gt;一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员。（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。&lt;/p&gt;

&lt;h1 id=&#34;虚函数&#34;&gt;虚函数&lt;/h1&gt;

&lt;h2 id=&#34;virtual&#34;&gt;virtual&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;只能修饰成员函数，不能修饰非成员函数&lt;/li&gt;
&lt;li&gt;不能修饰静态成员函数&lt;/li&gt;
&lt;li&gt;不能修饰构造函数&lt;/li&gt;
&lt;li&gt;不能修饰内联函数，若修饰内联函数，编译器会自动忽略掉inline关键字&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现原理-1&#34;&gt;实现原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;当类中含有虚函数时，则在实例化该类的对象时，则会产生一个虚函数表，并且该对象中包含指向该虚函数表的指针，称为虚函数表指针。在一个含有虚函数的对象中，虚函数表指针占据该对象所占据内存空间的前四个地址单位（32位 x86机器中）&lt;/li&gt;
&lt;li&gt;当使用一个基类的指针指向派生类的对象时，则会通过该指针访问到派生类的虚函数表指针，从而进一步访问到派生类的虚函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;虚析构函数&#34;&gt;虚析构函数&lt;/h2&gt;

&lt;p&gt;当使用基类指针指向派生类对象时，则会通过该指针访问到派生类的虚函数表指针，从而进一步访问到派生类的虚析构函数。所以当释放该基类指针时，则会执行派生类的虚析构函数，派生类的析构函数执行完毕后则会自动执行基类的析构函数&lt;/p&gt;

&lt;h2 id=&#34;纯虚函数&#34;&gt;纯虚函数&lt;/h2&gt;

&lt;p&gt;纯虚函数的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt; virtual void func() = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯虚函数的函数指针也保存在虚函数表中，且函数指针的值等于0；纯虚函数不必进行具体实现。&lt;/p&gt;

&lt;h2 id=&#34;抽象类&#34;&gt;抽象类&lt;/h2&gt;

&lt;p&gt;含有纯虚函数的类，称为抽象类，该类不能创建对象(抽象类不能实例化)。一个继承于抽象类的子类，只有实现了父类所有的抽象方法才能够是非抽象类。&lt;/p&gt;

&lt;h2 id=&#34;接口类&#34;&gt;接口类&lt;/h2&gt;

&lt;p&gt;只含有纯虚函数，而不含有其他成员函数和数据成员的类，称为接口类。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;抽象类&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;接口类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;构造方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以有构造方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能有构造方法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;成员变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以有普通成员变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能有普通成员变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;非纯虚函数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以有实现了的方法&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;必须全部为纯虚函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;纯虚函数的访问类型&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以是public、protected&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;必须为public&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;静态成员函数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可包含静态成员函数&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不能包含静态成员函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;静态成员变量&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以有，访问类型可以为任意&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可以有，访问类型为public、static、final&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;重载overload覆盖override与隐藏hding&#34;&gt;重载（overload）、覆盖（override）与隐藏（hding）&lt;/h1&gt;

&lt;h2 id=&#34;重载&#34;&gt;重载&lt;/h2&gt;

&lt;p&gt;重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。&lt;/p&gt;

&lt;h3 id=&#34;重载的条件&#34;&gt;重载的条件：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;相同范围（在同一个类中）&lt;/li&gt;
&lt;li&gt;函数名字相同&lt;/li&gt;
&lt;li&gt;参数不同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virtual&lt;/code&gt;关键字可有可无&lt;/li&gt;
&lt;li&gt;不能通过访问权限、返回类型、抛出的异常进行重载&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;覆盖&#34;&gt;覆盖&lt;/h2&gt;

&lt;p&gt;覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。&lt;/p&gt;

&lt;h3 id=&#34;覆盖的条件&#34;&gt;覆盖的条件：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不同范围（分别位于派生类和基类中）&lt;/li&gt;
&lt;li&gt;函数名字相同&lt;/li&gt;
&lt;li&gt;参数相同&lt;/li&gt;
&lt;li&gt;返回类型相同&lt;/li&gt;
&lt;li&gt;基类函数必须有&lt;code&gt;vitual&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;覆盖方法的访问修饰符一定要大于被覆盖方法的访问修饰符（public &amp;gt; protected &amp;gt; default &amp;gt; private）&lt;/li&gt;
&lt;li&gt;被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;隐藏&#34;&gt;隐藏&lt;/h2&gt;

&lt;p&gt;隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。&lt;/p&gt;

&lt;h3 id=&#34;隐藏条件&#34;&gt;隐藏条件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无&lt;code&gt;virtual&lt;/code&gt;关键字，基类的函数将被隐藏&lt;/li&gt;
&lt;li&gt;如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有&lt;code&gt;virtual&lt;/code&gt;关键字。此时，基类的函数被隐藏&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;initializerlist-列表初始化&#34;&gt;initializer_list 列表初始化&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;常成员变量必须在初始化列表中初始化&lt;/li&gt;
&lt;li&gt;成员类型是没有默认构造函数的类，必须在初始化列表中初始化&lt;/li&gt;
&lt;li&gt;成员变量的初始化顺序与初始化列表中的顺序无关，只与在类中声明的顺序有关&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;extern-c&#34;&gt;extern &amp;quot;C&amp;quot;&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;extern &amp;quot;C&amp;quot; 只是一种连接约定，并不影响调用函数的语义&lt;/li&gt;
&lt;li&gt;在每个C ++程序中，所有非静态函数都在二进制文件中表示为符号。这些符号是特殊文本字符串，用于唯一标识程序中的函数。&lt;/li&gt;
&lt;li&gt;在C中，符号名称与函数名称相同。&lt;/li&gt;
&lt;li&gt;因为C++允许重载并且具有C不具备的许多功能 - 比如类，成员函数，异常规范 - 所以不可能简单地使用函数名作为符号名。为了解决这个问题，C++使用了所谓的名称修改，它将函数名称和所有必要信息（如参数的数量和类型）转换为仅由编译器和链接器处理的字符串。&lt;/li&gt;
&lt;li&gt;由于C和C++对符号处理的不同这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。&lt;/li&gt;
&lt;li&gt;将函数指定为extern &amp;quot;C&amp;quot;，则编译器不会对其执行名称修改，并且可以使用其符号名称作为函数名称直接访问它。&lt;/li&gt;
&lt;li&gt;经常使用条件编译建立起公共的C和C++头文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
    ...
    ...
#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;实现类string&#34;&gt;实现类String&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class String {
public:
    String(const char *str = nullptr); // 通用构造函数
    String(const String &amp;amp;another); // 拷贝构造函数
    String&amp;amp; operater =(const String &amp;amp;rhs); // 赋值函数
    ~String(); // 析构函数
private:
    char *m_data;
};
String::String(const char *str = NULL) {
    if (str == nullptr) {
        m_data = new char[1];
        m_data[0] = &#39;/0&#39;;
    } else {
        m_data = new char[strlen(str) + 1];
        strcpy(m_data, str);
    }
}
String::String(const String&amp;amp; another) {
    m_data = new char[strlen(another.m_data) + 1];
    strcpy(m_data, another.m_data);
}
String&amp;amp; String::operator=(const String&amp;amp; another) {
    if (this != &amp;amp;another) {
        String strTmp(another);
        char *pTmp = strTmp.m_data;
        strTmp.m_data = m_data;
        m_data = pTmp;
    }
    return *this;
}
String::~String() {
    delete[] m_data;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;实现单例模式&#34;&gt;实现单例模式&lt;/h1&gt;

&lt;h2 id=&#34;饿汉模式&#34;&gt;饿汉模式&lt;/h2&gt;

&lt;p&gt;单例实例在程序运行时被立即执行初始化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class singleton {
public:
    static string&amp;amp; getInstance() {
        return instance;
    }
private:
    singleton() {}
    singleton(const singleton&amp;amp;) {}
    singleton&amp;amp; operator=(const singleton&amp;amp;) {}
    ~singleton() {}
    static singleton instance;
};

// init
singleton singleton::instance;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于在main函数之前初始化，所以没有线程安全的问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。也即，&lt;code&gt;static singleton instance&lt;/code&gt;和&lt;code&gt;static singleton&amp;amp; getInstance()&lt;/code&gt;二者的初始化顺序不确定，如果在初始化完成之前调用 &lt;code&gt;getInstance()&lt;/code&gt; 方法会返回一个未定义的实例。&lt;/p&gt;

&lt;h2 id=&#34;懒汉模式&#34;&gt;懒汉模式&lt;/h2&gt;

&lt;p&gt;单例实例在第一次被使用时才进行初始化，这叫做延迟初始化。&lt;/p&gt;

&lt;h3 id=&#34;单线程环境&#34;&gt;单线程环境&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class singleton {
public:
    static singleton* getInstance() {
        if (instance == nullptr) {
            instance = new singleton();
        }
        return instance;
    }
private:
    singleton() {}
    singleton(const singleton&amp;amp;) {}
    singleton&amp;amp; operator=(const singleton&amp;amp;) {}
    ~singleton() {}
    static singleton* instance;
};

// init
singleton* singleton::instance = nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面代码存在内存泄漏问题，可以采用智能指针和使用静态的嵌套类对象来解决。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class singleton {
public:
    static singleton* getInstance() {
        if (instance == nullptr) {
            instance = new singleton();
        }
        return instance;
    }
private:
    singleton() {}
    singleton(const singleton&amp;amp;) {}
    singleton&amp;amp; operator=(const singleton&amp;amp;) {}
    ~singleton() {}
    class deletor {
        public:
            ~deletor() {
                if (singleton::instance != nullptr) {
                    delete singleton::instance;
                }
            }
    };
    static deletor deletorInstance;
    static singleton* instance;
};

// init
singleton* singleton::instance = nullptr;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在程序运行结束时，系统会调用静态成员&lt;code&gt;deletorInstance&lt;/code&gt;的析构函数，该析构函数会删除单例的唯一实例。&lt;/p&gt;

&lt;h3 id=&#34;多线程环境&#34;&gt;多线程环境&lt;/h3&gt;

&lt;p&gt;使用双检测锁模式（DCL: Double-Checked Locking Pattern）。线程安全问题仅出现在第一次初始化（new）过程中，而在后面获取该实例的时候并不会遇到，它通过加锁前检测是否已经初始化，避免了每次获取实例时都要首先获取锁资源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;static singleton* getInstace() {
    if (instance == nullptr) {
        Lock lock;  // 基于作用域的加锁，超出作用域，自动调用析构函数解锁
        if (instance == nullptr) {
            instance = new singleton();
        }
    }
    return instance;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;best-of-all&#34;&gt;best of all&lt;/h3&gt;

&lt;p&gt;C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的 local static 对象。这样，只有当第一次访问&lt;code&gt;getInstance()&lt;/code&gt;方法时才创建实例。这种方法也被称为Meyers&#39; Singleton。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class singleton {
public:
    static singleton&amp;amp; getInstance() {
        static singleton instance;
        return instance;
    }
private:
    singleton() {}
    singleton(const singleton&amp;amp;) {}
    singleton&amp;amp; operator=(const singleton&amp;amp;) {}
    ~singleton() {}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;内存泄露&#34;&gt;内存泄露&lt;/h1&gt;

&lt;p&gt;如何避免内存泄漏：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用RAII(Resource Acquisition Is Initialization,资源获取即初始化)技法，以构造函数获取资源(内存)，析构函数释放资源&lt;/li&gt;
&lt;li&gt;使用智能指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;野指针&#34;&gt;野指针&lt;/h2&gt;

&lt;p&gt;野指针指的是还没有初始化的指针&lt;/p&gt;

&lt;h2 id=&#34;悬空指针&#34;&gt;悬空指针&lt;/h2&gt;

&lt;p&gt;一个指针的指向对象已被删除，那么就成了悬空指针&lt;/p&gt;

&lt;h2 id=&#34;智能指针&#34;&gt;智能指针&lt;/h2&gt;

&lt;h3 id=&#34;sharedptr&#34;&gt;shared_ptr&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;多个指针指向相同的对象。&lt;code&gt;shared_ptr&lt;/code&gt;使用引用计数，每一个&lt;code&gt;shared_ptr&lt;/code&gt;的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。&lt;code&gt;shared_ptr&lt;/code&gt;内部的引用计数是线程安全的，即引用计数的加减操作都是原子的，但是对象的读取需要加锁&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt;内部包含两个指针，一个指向对象，另一个指向控制块(control block)，控制块中包含一个引用计数和其它一些数据&lt;/li&gt;
&lt;li&gt;可以通过&lt;code&gt;unique_ptr&lt;/code&gt;来构造&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;int&amp;gt; p1{new int(0)};
unqiue_ptr&amp;lt;int&amp;gt; p2{std::move(p1)};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;不能通过同一个raw pointer来构造多个&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;make_shared&lt;/code&gt;来创建&lt;code&gt;shared_ptr&lt;/code&gt;会高效，因为&lt;code&gt;make_shared&lt;/code&gt;仅使用new操作一次，它的做法是在 heap 上分配一块连续的内存用来容纳&lt;code&gt;string(&amp;quot;hello&amp;quot;)&lt;/code&gt;和控制块。同样，当&lt;code&gt;shared_ptr&lt;/code&gt;的被析构时，也只需一次&lt;code&gt;delete&lt;/code&gt;操作&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;shared_ptr&amp;lt;string&amp;gt; p1{new string(&amp;quot;hello&amp;quot;)}; // 调用两次new操作，一次申请string空间，一次申请控制块空间
shared_ptr&amp;lt;string&amp;gt; p2 = make_shared&amp;lt;string&amp;gt;(&amp;quot;hello&amp;quot;); // 只调用一次new操作
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;循环引用&#34;&gt;循环引用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;shared_ptr&lt;/code&gt;时，不可避免地会遇到循环引用的情况，这样容易导致内存泄露&lt;/li&gt;
&lt;li&gt;为避免循环引用导致的内存泄露，就需要使用&lt;code&gt;weak_ptr&lt;/code&gt;，&lt;code&gt;weak_ptr&lt;/code&gt;并不拥有其指向的对象，也就是说，让&lt;code&gt;weak_ptr&lt;/code&gt;指向&lt;code&gt;shared_ptr&lt;/code&gt;所指向对象，对象的引用计数并不会增加&lt;/li&gt;
&lt;li&gt;只需要将环中的某个&lt;code&gt;shared_ptr&lt;/code&gt;替换为&lt;code&gt;weak_ptr&lt;/code&gt;即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;uniqueptr&#34;&gt;unique_ptr&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;唯一拥有其所指对象，同一时刻只能有一个&lt;code&gt;unique_ptr&lt;/code&gt;指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;内部存储一个 &lt;code&gt;raw pointer&lt;/code&gt;，当&lt;code&gt;unique_ptr&lt;/code&gt;析构时，它的析构函数将会负责析构它持有的对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;提供了&lt;code&gt;operator*()&lt;/code&gt;和&lt;code&gt;operator-&amp;gt;()&lt;/code&gt;成员函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;并不提供 &lt;code&gt;copy&lt;/code&gt; 操作，这是为了防止多个&lt;code&gt;unique_ptr&lt;/code&gt;指向同一对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;提供了 &lt;code&gt;move&lt;/code&gt; 操作，因此我们可以用&lt;code&gt;std::move()&lt;/code&gt;来转移&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C++14 提供了&lt;code&gt;std::make_unique&amp;lt;T&amp;gt;()&lt;/code&gt;函数用来直接创建&lt;code&gt;unique_ptr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;weakptr&#34;&gt;weak_ptr&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;并不拥有其指向的对象，也就是说，让&lt;code&gt;weak_ptr&lt;/code&gt;指向&lt;code&gt;shared_ptr&lt;/code&gt;所指向对象，对象的引用计数并不会增加&lt;/li&gt;
&lt;li&gt;因为&lt;code&gt;weak_ptr&lt;/code&gt;不持有对象，所以不能通过&lt;code&gt;weak_ptr&lt;/code&gt;去访问对象的成员&lt;/li&gt;
&lt;li&gt;由&lt;code&gt;weak_ptr&lt;/code&gt;来构造&lt;code&gt;shared_ptr&lt;/code&gt;由两种方式：

&lt;ul&gt;
&lt;li&gt;调用&lt;code&gt;weak_ptr&lt;/code&gt;的&lt;code&gt;lock()&lt;/code&gt;方法，要是对象已被析构，那么&lt;code&gt;lock()&lt;/code&gt;返回一个空的&lt;code&gt;shared_ptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;weak_ptr&lt;/code&gt;传递给&lt;code&gt;shared_ptr&lt;/code&gt;的构造函数，要是对象已被析构，则抛出&lt;code&gt;std::exception&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;weak_ptr&lt;/code&gt;并不持有对象，因此其指向的对象可能已析构了，判断其所指对象是否析构有两种方法：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;的&lt;code&gt;use_count()&lt;/code&gt;方法，判断引用计数是否为0&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;weak_pt&lt;/code&gt;r的&lt;code&gt;expired()&lt;/code&gt;方法，若对象已经被析构，则&lt;code&gt;expired()&lt;/code&gt;将返回&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;智能指针的实现&#34;&gt;智能指针的实现&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;typename T&amp;gt;
class smartPtr{
public:
    smartPtr(T *ptr = nullptr) : m_ptr(ptr) {
        if (ptr == nullptr) {
            *m_pRefCount = 0;
        } else {
            *m_pRefCount = 1;
        }
    }
    smartPtr(const smartPtr&amp;amp; another) {
        m_ptr = anothter.m_ptr;
        m_pRefCount = another.m_pRefCount;
        ++*m_pRefCount;
    }
    smartPtr&amp;amp; operator=(const smartPtr&amp;amp; another) {
        if (this != &amp;amp;another) {
            if (--*m_pRefCount == 0) {
                delete m_ptr;
                delete m_pRefCount;
            }
            m_ptr = another.m_ptr;
            m_pRefCount = another.m_pRefCount;
            ++*m_pRefCount;
        }
        return *this;
    }
    T* operator-&amp;gt;() {
        assert(m_ptr == nullptr);
        return m_ptr;
    }
    T&amp;amp; operator*() {
        assert(m_ptr == nullptr);
        return *m_ptr;
    }
private:
    T *m_ptr;
    size_t *m_pRefCount;
};

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;类型转换&#34;&gt;类型转换&lt;/h1&gt;

&lt;h2 id=&#34;staticcast&#34;&gt;static_cast&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用于基本数据类型之间的转换，如int-&amp;gt;float等&lt;/li&gt;
&lt;li&gt;把空指针转换成目标类型的空指针&lt;/li&gt;
&lt;li&gt;把任何类型的表达式类型转换成void类型&lt;/li&gt;
&lt;li&gt;用于类层次结构中父类和子类之间指针和引用的转换。进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。&lt;/li&gt;
&lt;li&gt;static_cast不能转换掉expression的const、volatile、或者__unaligned属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;constcast&#34;&gt;const_cast&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用于 const 与非 const、volatile 与非 volatile 之间的转换&lt;/li&gt;
&lt;li&gt;const_cast一般用于修改指针&lt;/li&gt;
&lt;li&gt;如果有一个函数，它的形参是non-const类型变量，而且函数不会对实参的值进行改动，这时我们可以使用类型为const的变量来调用函数，此时可使用const_cast&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void foo(int* num) {
    cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl;
}

int main()
{
    const int num = 0;
    foo(const_cast&amp;lt;int*)(&amp;amp;num));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dynamiccast&#34;&gt;dynamic_cast&lt;/h2&gt;

&lt;p&gt;dynamic_cast 用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助 RTTI 进行检测，所以只有一部分能成功。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dynamic_cast 只能转换指针类型和引用类型&lt;/li&gt;
&lt;li&gt;对于指针，如果转换失败将返回 NULL；对于引用，如果转换失败将抛出&lt;code&gt;std::bad_cast&lt;/code&gt;异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;向上转型&#34;&gt;向上转型&lt;/h3&gt;

&lt;p&gt;向上转型时，只要待转换的两个类型之间存在继承关系，并且基类包含了虚函数（这些信息在编译期间就能确定），就一定能转换成功。因为向上转型始终是安全的，所以 dynamic_cast 不会进行任何运行期间的检查，这个时候的 dynamic_cast 和 static_cast 就没有什么区别&lt;/p&gt;

&lt;h3 id=&#34;向下转型&#34;&gt;向下转型&lt;/h3&gt;

&lt;p&gt;向下转型是有风险的，dynamic_cast 会借助 RTTI 信息进行检测，确定安全的才能转换成功，否则就转换失败。&lt;/p&gt;

&lt;p&gt;当使用 dynamic_cast 对指针进行类型转换时，程序会先找到该指针指向的对象，再根据对象找到当前类（指针指向的对象所属的类）的类型信息，并从此节点开始沿着继承链向上遍历，如果找到了要转化的目标类型，那么说明这种转换是安全的，就能够转换成功，如果没有找到要转换的目标类型，那么说明这种转换存在较大的风险，就不能转换。&lt;/p&gt;

&lt;h2 id=&#34;reinterpretcast&#34;&gt;reinterpret_cast&lt;/h2&gt;

&lt;p&gt;reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高。&lt;/p&gt;

&lt;h1 id=&#34;raii&#34;&gt;RAII&lt;/h1&gt;

&lt;p&gt;RAII是Resource Acquisition Is Initialization（“资源获取即初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。
一般采用如下方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;利用“函数的局部对象无论函数以何种方式(包括因异常)结束都会被析构”这一特性，将“一定要释放的资源”放进局部对象的析构函数；&lt;/li&gt;
&lt;li&gt;使用智能指针。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;rtti&#34;&gt;RTTI&lt;/h1&gt;

&lt;p&gt;RTTI是“Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。&lt;/p&gt;

&lt;h1 id=&#34;stl&#34;&gt;STL&lt;/h1&gt;

&lt;h2 id=&#34;map与unorderedmap&#34;&gt;map与unordered_map&lt;/h2&gt;

&lt;h3 id=&#34;mapset&#34;&gt;map/set&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;底层实现是红黑树&lt;/li&gt;
&lt;li&gt;红黑树特点

&lt;ul&gt;
&lt;li&gt;节点要么是红色，要么是黑色&lt;/li&gt;
&lt;li&gt;根节点为黑色&lt;/li&gt;
&lt;li&gt;每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;unordered-mapset&#34;&gt;unordered map/set&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;底层实现是hash表&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;c-11&#34;&gt;c++ 11&lt;/h1&gt;

&lt;h2 id=&#34;范围-for&#34;&gt;范围 for&lt;/h2&gt;

&lt;h2 id=&#34;auto-decltype&#34;&gt;auto decltype&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;decltype：编译时类型推导，以一个普通表达式为参数，返回该表达式类型，并不会对该表达式求值&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;final-override&#34;&gt;final override&lt;/h2&gt;

&lt;h2 id=&#34;stdmove-stdforward&#34;&gt;std::move std::forward&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;std::move() 接受一个参数，然后返回一个该参数对应的右值引用&lt;/li&gt;
&lt;li&gt;std::forward() 接受一个参数，然后返回该参数本来所对应的类型的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;deafulted-deleted&#34;&gt;deafulted deleted&lt;/h2&gt;

&lt;h3 id=&#34;deafulted&#34;&gt;deafulted&lt;/h3&gt;

&lt;p&gt;C++ 的类有四类特殊成员函数，它们分别是：默认构造函数、析构函数、拷贝构造函数以及拷贝赋值运算符。这些类的特殊成员函数负责创建、初始化、销毁，或者拷贝类的对象。如果程序员没有显式地为一个类定义某个特殊成员函数，而又需要用到该特殊成员函数时，则编译器会隐式的为这个类生成一个默认的特殊成员函数。但是，如果程序员为类 X 显式的自定义了非默认构造函数，编译器将不再会为它隐式的生成默认构造函数。如果需要用到默认构造函数来创建类的对象时，程序员必须自己显式的定义默认构造函数。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Defaulted 函数特性仅适用于类的特殊成员函数，且该特殊成员函数没有默认参数&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;deleted&#34;&gt;deleted&lt;/h3&gt;

&lt;p&gt;为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：deleted 函数。必须在函数第一次声明的时候将其声明为 deleted 函数，否则编译器会报错。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序员只需在函数声明后加上“=delete;”，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 deleted 函数，就可以禁止类 X 对象之间的拷贝和赋值&lt;/li&gt;
&lt;li&gt;Deleted 函数特性还可以用来禁用某些用户自定义的类的 new 操作符，从而避免在自由存储区创建类的对象&lt;/li&gt;
&lt;li&gt;Deleted 函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数据库系统</title>
      <link>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;h1 id=&#34;视图&#34;&gt;视图&lt;/h1&gt;

&lt;p&gt;视图是一个虚拟表，其内容由查询定义。视图一经定义便存入数据库中。视图中的数据只是存放在基本表中的数据。&lt;/p&gt;

&lt;h2 id=&#34;视图作用&#34;&gt;视图作用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;简单性：视图可以简化用户的操作&lt;/li&gt;
&lt;li&gt;安全性：通过视图用户只能查询和修改他们所看到的数据&lt;/li&gt;
&lt;li&gt;逻辑数据独立性：视图可以帮助用户屏蔽真实表结构变化带来的影响&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;完整性约束&#34;&gt;完整性约束&lt;/h1&gt;

&lt;p&gt;关系完整性约束是为保证数据库中数据的正确性和相容性，对关系模型提出的某种约束条件或规则。完整性通常包括域完整性，实体完整性、参照完整性和用户定义完整性，其中域完整性，实体完整性和参照完整性，是关系模型必须满足的完整性约束条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;域完整性：保证指定列的数据具有正确的数据类型、格式和有效的数据范围&lt;/li&gt;
&lt;li&gt;实体完整性：指关系的主关键字不能重复也不能取“空值”，保证数据库中数据表的每一个特定实体的记录都是唯一的&lt;/li&gt;
&lt;li&gt;参照完整性：定义建立关系之间联系的主关键字与外部关键字引用的约束条件。当增加、修改或删除数据库表中记录时，可以借助参照完整性来保证相关联表之间数据的一致性&lt;/li&gt;
&lt;li&gt;用户定义完整性：由用户定义的完整性。用户定义完整性可以定义不属于其他任何完整性分类的特定业务规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;

&lt;p&gt;可参考：&lt;a href=&#34;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&#34;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;

&lt;h2 id=&#34;索引的优点&#34;&gt;索引的优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性&lt;/li&gt;
&lt;li&gt;可以大大加快数据的检索速度，这也是创建索引的最主要的原因&lt;/li&gt;
&lt;li&gt;可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义&lt;/li&gt;
&lt;li&gt;在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间&lt;/li&gt;
&lt;li&gt;通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;索引的缺点&#34;&gt;索引的缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加&lt;/li&gt;
&lt;li&gt;索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大&lt;/li&gt;
&lt;li&gt;当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设置索引的原则&#34;&gt;设置索引的原则&lt;/h2&gt;

&lt;h3 id=&#34;应设置索引的情况&#34;&gt;应设置索引的情况&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;较频繁查询的列上创建索引&lt;/li&gt;
&lt;li&gt;在经常需要根据范围进行搜索的列上创建索引&lt;/li&gt;
&lt;li&gt;在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构&lt;/li&gt;
&lt;li&gt;在经常用在连接的列上&lt;/li&gt;
&lt;li&gt;在经常需要排序的列上创建索引，因为索引已经排序&lt;/li&gt;
&lt;li&gt;在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不应设置索引的情况&#34;&gt;不应设置索引的情况&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在查询中很少使用或者参考的列不应该创建索引&lt;/li&gt;
&lt;li&gt;选择性很差的列，即这些列取值很少&lt;/li&gt;
&lt;li&gt;当修改性能远远大于检索性能时，不应该创建索引&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;索引分类&#34;&gt;索引分类：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;唯一索引：唯一索引不允许两行具有相同的索引值&lt;/li&gt;
&lt;li&gt;主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空&lt;/li&gt;
&lt;li&gt;聚集索引(Clustered)：表中各行的物理顺序与索引顺序相同，每个表只能有一个&lt;/li&gt;
&lt;li&gt;非聚集索引(Non-clustered)：非聚集索引指定表中记录的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;索引类型&#34;&gt;索引类型&lt;/h3&gt;

&lt;h4 id=&#34;顺序索引&#34;&gt;顺序索引&lt;/h4&gt;

&lt;p&gt;使用B树或者B+树作为其索引结构&lt;/p&gt;

&lt;h4 id=&#34;散列索引&#34;&gt;散列索引&lt;/h4&gt;

&lt;p&gt;哈希索引（hash index）基于哈希表实现。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。对于hash相同的，采用链表的方式解决冲突。&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;访问哈希索引的数据非常快&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;限制：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行&lt;/li&gt;
&lt;li&gt;哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序&lt;/li&gt;
&lt;li&gt;哈希索引只支持等值比较查询，包括=、IN()、&amp;lt;&amp;gt;，也不支持任何范围查询&lt;/li&gt;
&lt;li&gt;当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;散列索引与顺序索引的区别&#34;&gt;散列索引与顺序索引的区别&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Hash索引&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;顺序索引&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;实现方式&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Hash表&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B+树&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;是否有序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无序&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;有序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;查询方式&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;只支持点查询&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;支持点查询和范围查询&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;存储过程&#34;&gt;存储过程&lt;/h1&gt;

&lt;p&gt;存储过程是一个预编译的SQL语句。&lt;/p&gt;

&lt;h2 id=&#34;存储过程优点&#34;&gt;存储过程优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;存储过程是预编译过的，执行效率高&lt;/li&gt;
&lt;li&gt;存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯&lt;/li&gt;
&lt;li&gt;安全性高，执行存储过程需要有一定权限的用户&lt;/li&gt;
&lt;li&gt;存储过程可以重复使用，可减少数据库开发人员的工作量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;存储过程缺点&#34;&gt;存储过程缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个数据库的存储过程语法几乎都不一样，十分难以维护&lt;/li&gt;
&lt;li&gt;业务逻辑放在数据库上，难以迭代&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;存储过程和函数的区别&#34;&gt;存储过程和函数的区别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;存储过程&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;用途&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用于在数据库中完成特定的操作或者任务&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;用于特定的数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;声明&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明用procedure&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明用function&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;返回类型&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明时不需描述返回类型&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;程序头部声明时要描述返回类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;参数模式&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可以使用in/out/in out 三种模式的参数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可以使用in/out/in out 三种模式的参数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;能否独立执行&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;可作为一个独立的语句来执行&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不能独立执行，必须作为表达式的一部分调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;调用&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SQL语句(DML 或SELECT)中不可调用存储过程&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SQL语句(DML 或SELECT)中可以调用函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;触发器&#34;&gt;触发器&lt;/h2&gt;

&lt;p&gt;触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。&lt;/p&gt;

&lt;h1 id=&#34;join&#34;&gt;join&lt;/h1&gt;

&lt;h2 id=&#34;内连接&#34;&gt;内连接&lt;/h2&gt;

&lt;p&gt;在每个表中找出符合条件的共有记录&lt;/p&gt;

&lt;h2 id=&#34;外连接&#34;&gt;外连接&lt;/h2&gt;

&lt;h3 id=&#34;左连接&#34;&gt;左连接&lt;/h3&gt;

&lt;p&gt;根据左表的记录，在被连接的右表中找出符合条件的记录与之匹配，如果找不到与左表匹配的，用null表示&lt;/p&gt;

&lt;h3 id=&#34;右连接&#34;&gt;右连接&lt;/h3&gt;

&lt;p&gt;根据右表的记录，在被连接的左表中找出符合条件的记录与之匹配，如果找不到匹配的，用null填充&lt;/p&gt;

&lt;h3 id=&#34;全外连接&#34;&gt;全外连接&lt;/h3&gt;

&lt;p&gt;返回左表和右表中的所有记录。若某一行再另一个表中没有与之匹配的，用null表示（结果是左连接和右连接的并集）&lt;/p&gt;

&lt;h2 id=&#34;笛卡尔积交叉连接&#34;&gt;笛卡尔积（交叉连接）&lt;/h2&gt;

&lt;p&gt;将两个表中的每条记录都进行组合。不带WHERE条件子句，它将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积，如果带where，返回或显示的是匹配的行数（先生成笛卡尔积，再根据查询条件进行筛选）。&lt;/p&gt;

&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;

&lt;p&gt;事务是并发控制的基本单元。事务是一个操作序列，由一条或多条SQL语句组成，这些操作要么都执行成功，要么都不执行，它是一个不可分割的工作单位。&lt;/p&gt;

&lt;h2 id=&#34;事务的acid特性&#34;&gt;事务的ACID特性：&lt;/h2&gt;

&lt;h3 id=&#34;原子性atomicity&#34;&gt;原子性（Atomicity）&lt;/h3&gt;

&lt;p&gt;事务是不可分割的工作单位。只有事务中的全部操作执行成功，事务才算执行成功。若任何操作失败，则该事务执行失败，数据库的状态必须回滚到事务开始前的状态。&lt;/p&gt;

&lt;h3 id=&#34;一致性consistency&#34;&gt;一致性（Consistency）&lt;/h3&gt;

&lt;p&gt;事务应保证数据库只能从一个一致状态转移到另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。即事务开始前和结束后数据库数据的完整性没有被破坏。&lt;/p&gt;

&lt;h3 id=&#34;隔离性isolation&#34;&gt;隔离性（Isolation）&lt;/h3&gt;

&lt;p&gt;事务的隔离性要求每个事务的对象和其它事务的操作对象能相互分离。即该事务提交前对其它事务都不可见，这通常使用锁来实现。多个事务并发执行时，一个事务的执行不应影响其他事务的执行。&lt;/p&gt;

&lt;h3 id=&#34;持久性durability&#34;&gt;持久性（Durability）&lt;/h3&gt;

&lt;p&gt;事务一旦提交其结果就是永久性的。即数据写入到了数据库中，即使宕机数据也不会丢失。&lt;/p&gt;

&lt;h2 id=&#34;可串行化&#34;&gt;可串行化&lt;/h2&gt;

&lt;p&gt;可串行化指事务并行执行的结果与某个顺序的串行执行结果相同。可串行化&lt;/p&gt;

&lt;h3 id=&#34;先后顺序图串行化图&#34;&gt;先后顺序图/串行化图&lt;/h3&gt;

&lt;p&gt;对于调度S，先后顺序图是一个有向图 &lt;span  class=&#34;math&#34;&gt;\(G = (N, E)\)&lt;/span&gt;，由节点集合 &lt;span  class=&#34;math&#34;&gt;\(N\)&lt;/span&gt; 和有向边集合 &lt;span  class=&#34;math&#34;&gt;\(E\)&lt;/span&gt; 构成，构建方式如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为每个事务创建一个节点&lt;/li&gt;
&lt;li&gt;如果事务 &lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt; 读取了 &lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt; 已经写操作的数据项，创建一条有向边 &lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果事务 &lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt; 对 &lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt; 已经读取的数据项进行写操作，创建一条有向边 &lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果事务 &lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt; 对 &lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt; 写操作的数据项进行写操作，创建一条有向边 &lt;span  class=&#34;math&#34;&gt;\(T_j \to T_i\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果 &lt;span  class=&#34;math&#34;&gt;\(S\)&lt;/span&gt; 的先后顺序图中出现了有向边 &lt;span  class=&#34;math&#34;&gt;\(T_i \to T_j\)&lt;/span&gt;，则在任何与之等价的串行调度 &lt;span  class=&#34;math&#34;&gt;\(S&#39;\)&lt;/span&gt; 中，&lt;span  class=&#34;math&#34;&gt;\(T_i\)&lt;/span&gt; 必须出现在 &lt;span  class=&#34;math&#34;&gt;\(T_j\)&lt;/span&gt; 的前面。如果先后顺序图中存在环，则该调度不可串行化。&lt;/p&gt;

&lt;h2 id=&#34;数据冲突引起的问题&#34;&gt;数据冲突引起的问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;脏读（read uncommitted data）：在 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt; 读取了 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 已经修改了的数据&lt;/li&gt;
&lt;li&gt;不可重复读（unreaptable read）：在 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt; 修改了 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 已经读取的数据，如果 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 再次读取该数据，则发现不同的值&lt;/li&gt;
&lt;li&gt;更新丢失（overwrite uncommitted data）：在 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 提交前，&lt;span  class=&#34;math&#34;&gt;\(T_1\)&lt;/span&gt; 修改了 &lt;span  class=&#34;math&#34;&gt;\(T_2\)&lt;/span&gt; 已经写的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;read uncommit 读脏数据&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;unreaptable read 不可重复读&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;overwrite uncommitted 更新丢失&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Read uncommited 读未提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Read committed 读已提交&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Reaptable read 重复读取&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Serializable&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可能&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;解决冲突的乐观与悲观方法&#34;&gt;解决冲突的乐观与悲观方法&lt;/h2&gt;

&lt;h3 id=&#34;悲观技术&#34;&gt;悲观技术&lt;/h3&gt;

&lt;h4 id=&#34;加锁方法&#34;&gt;加锁方法&lt;/h4&gt;

&lt;p&gt;加锁是并发事务串行化的常用方法。事务必须在开始数据库读/写操作前获声明一个共享的（读）锁或者互斥的（写）锁。如果声明互斥锁，锁禁止其他事务修改甚至读取该数据项。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;共享锁：如果事务在一个数据项上加上共享锁，他只能读而不能更新该数据项。&lt;/li&gt;
&lt;li&gt;互斥锁：如果事务在一个数据项上加上互斥锁，他既能读也能更新该数据项。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;读操作是不冲突的，因此允许多个并发事务获取数据项的共享锁。另一方面，互斥锁赋予事务对该数据项的独占的访问权限，因此其他事务都无法读取或者更新该数据项。&lt;/p&gt;

&lt;h5 id=&#34;两段锁2pl协议&#34;&gt;两段锁（2PL）协议&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务对一个数据项操作之前，必须先获得对该项的锁&lt;/li&gt;
&lt;li&gt;一旦事务释放了第一个锁，就不能再获得任何新锁&lt;/li&gt;
&lt;li&gt;如果允许对锁进行升级，只能在增长阶段进行，且事务必须等待，直到另一个事务释放了该数据项的共享锁。锁的降级只能在缩减阶段进行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;算法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在Transaction开始时，对每个需要访问的数据加锁；如果不能加锁，就等待，直到加锁成功&lt;/li&gt;
&lt;li&gt;执行Transaction的内容&lt;/li&gt;
&lt;li&gt;在Transaction commit前，集中进行解锁&lt;/li&gt;
&lt;li&gt;Commit&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;锁的粒度&#34;&gt;锁的粒度&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;意向锁

&lt;ul&gt;
&lt;li&gt;IS(a)：将对a下面更细粒度的数据元素进行读&lt;/li&gt;
&lt;li&gt;IX(a)：将对a下面更细粒度的数据元素进行写&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了得到S，IS：所有祖先必须为IS或IX&lt;/li&gt;
&lt;li&gt;为了得到X，IX：所有祖先必须为IX&lt;/li&gt;
&lt;li&gt;锁兼容性矩阵：&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IS&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IX&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;S&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;X&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;IS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;IX&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;S&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\checkmark\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;X&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;span  class=&#34;math&#34;&gt;\(\times\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;时间戳方法&#34;&gt;时间戳方法&lt;/h4&gt;

&lt;p&gt;在时间戳方法中，较旧的事务（即有较小时间戳的事务），在冲突事件中有较高的优先级。采用时间戳协议，如果一个事务试图读或写一个数据项。只有当该数据项是由一个较旧事务更新时，这次读写才被允许。否则，请求读/写的事务将重新启动，并获得一个新的时间戳。&lt;/p&gt;

&lt;p&gt;每个数据项也有一个读时间戳（其值为最后一个读该数据项事务的时间戳）和一个写时间戳（其值为最后一个写该数据项事务的时间戳）。&lt;/p&gt;

&lt;h5 id=&#34;时间戳排序协议&#34;&gt;时间戳排序协议&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务&lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt;发出一个读请求 &lt;span  class=&#34;math&#34;&gt;\(read(x)\)&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;反之，若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则读操作继续，并令 &lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事务T发出一个写请求 &lt;span  class=&#34;math&#34;&gt;\(write(x)\)&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;否则，&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) \le T_{timestamp}\)&lt;/span&gt; 且 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则写操作继续，并令 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;托马斯写规则&#34;&gt;托马斯写规则&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;事务T发出一个写请求 &lt;span  class=&#34;math&#34;&gt;\(write(x)\)&lt;/span&gt;

&lt;ul&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则写操作被忽略&lt;/li&gt;
&lt;li&gt;若 &lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) &gt; T_{timestamp}\)&lt;/span&gt;，则事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 将被回滚，并以一个新的时间戳启动&lt;/li&gt;
&lt;li&gt;否则，&lt;span  class=&#34;math&#34;&gt;\(readTimestamp(x) \le T_{timestamp}\)&lt;/span&gt; 且 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) \le T_{timestamp}\)&lt;/span&gt;，则写操作继续，并令 &lt;span  class=&#34;math&#34;&gt;\(writeTimestamp(x) = T_{timestamp}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;乐观技术&#34;&gt;乐观技术&lt;/h3&gt;

&lt;p&gt;乐观技术基于这样一个假设：冲突是罕见的，去除为保证串行化而对事务的延迟，将会更高效。在事务提交时进行检查，若发生冲突，事务必须被回滚。&lt;/p&gt;

&lt;p&gt;事务执行分为三个阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读&lt;/strong&gt;：事务开始执行，读数据到私有工作区，并在私有工作区上完成事务的处理请求，完成修改操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证&lt;/strong&gt;：如果事务决定提交，检查事务是否与其它事务冲突

&lt;ul&gt;
&lt;li&gt;如果存在冲突，那么终止事务，清空私有工作区&lt;/li&gt;
&lt;li&gt;重试事务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写&lt;/strong&gt;：验证通过，没有发现冲突，那么把私有工作区的修改复制到数据库公共数据中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;确认阶段检查事务的读写操作是否发生了冲突。每个事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 开始时分配一个时间戳 &lt;span  class=&#34;math&#34;&gt;\(start(T)\)&lt;/span&gt;，事务的验证阶段分配时间戳 &lt;span  class=&#34;math&#34;&gt;\(validate(T)\)&lt;/span&gt;，事务的结束阶段 &lt;span  class=&#34;math&#34;&gt;\(finish(T)\)&lt;/span&gt;。通过确认检查，需满足以下条件之一：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 开始前，所有较旧时间戳的事务 &lt;span  class=&#34;math&#34;&gt;\(S\)&lt;/span&gt; 均已完成，即 &lt;span  class=&#34;math&#34;&gt;\(start(T) &gt; finish(S)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 在一个较旧的事务 &lt;span  class=&#34;math&#34;&gt;\(S\)&lt;/span&gt; 结束前开始，则：

&lt;ul&gt;
&lt;li&gt;&lt;span  class=&#34;math&#34;&gt;\(S\)&lt;/span&gt; 所写数据不是当前事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 读取的数据，（保证较旧事务的写不被当前事务读）且&lt;/li&gt;
&lt;li&gt;当前事务 &lt;span  class=&#34;math&#34;&gt;\(T\)&lt;/span&gt; 进入验证阶段前，所有较旧事务 &lt;span  class=&#34;math&#34;&gt;\(S\)&lt;/span&gt; 已完成其写阶段，即 &lt;span  class=&#34;math&#34;&gt;\(validate(T) &gt; finish(S) &gt; start(T)\)&lt;/span&gt;。（保证写是串行的）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;数据库的恢复&#34;&gt;数据库的恢复&lt;/h1&gt;

&lt;p&gt;采用如下机制进行恢复：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;备份机制：周期地对数据库进行备份&lt;/li&gt;
&lt;li&gt;日志机制：跟踪当前事务的状态与数据库的改变&lt;/li&gt;
&lt;li&gt;检查点机制：数据库与事务日志文件的同步点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wal-写前日志&#34;&gt;WAL 写前日志&lt;/h2&gt;

&lt;h3 id=&#34;日志文件&#34;&gt;日志文件&lt;/h3&gt;

&lt;p&gt;日志文件包括下列数据：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;事务记录

&lt;ul&gt;
&lt;li&gt;事务标识符&lt;/li&gt;
&lt;li&gt;日志记录类型（事务开始，插入，删除，更新，撤销，提交）&lt;/li&gt;
&lt;li&gt;所操作数据项的标识符（更新，插入，删除）&lt;/li&gt;
&lt;li&gt;数据项的前像&lt;/li&gt;
&lt;li&gt;数据项的后像&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;检查点记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果系统发生故障，恢复过程使用日志对事物进行撤销或重做：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果“事务开始”和“事务提交”都出现在日志中，使用日志记录来重做，按日志写入更新后字段的后像&lt;/li&gt;
&lt;li&gt;如果“事务开始”出现在日志文件中，但是“事务提交”未出现，则进行撤销，根据日志文件中数据项的前像，使数据库恢复到事务开始前的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;三个范式&#34;&gt;三个范式&lt;/h1&gt;

&lt;h2 id=&#34;第一范式&#34;&gt;第一范式&lt;/h2&gt;

&lt;p&gt;所有属性都是不可分的基本数据项&lt;/p&gt;

&lt;h2 id=&#34;第二范式&#34;&gt;第二范式&lt;/h2&gt;

&lt;p&gt;每个表有且仅有一个数据元素为主键，其他数据元素与主键一一对应&lt;/p&gt;

&lt;h2 id=&#34;第三范式&#34;&gt;第三范式&lt;/h2&gt;

&lt;p&gt;指表中的所有数据元素不但要能唯一地被主键所标识，而且他们之间还必须相互独立，不存在其他的函数关系。&lt;/p&gt;

&lt;h1 id=&#34;nosql&#34;&gt;No-SQL&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络基础</title>
      <link>https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;计算机网络模型&#34;&gt;计算机网络模型&lt;/h1&gt;

&lt;h2 id=&#34;osi-七层模型&#34;&gt;OSI 七层模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;物理层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：比特 Bit&lt;/li&gt;
&lt;li&gt;功能作用：确定与传输媒介的接口的一些特性，电气，机械，功能，规程特性&lt;/li&gt;
&lt;li&gt;设备：中继器，集线器&lt;/li&gt;
&lt;li&gt;协议：RJ45等
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据链路层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据链路层可以划分为：逻辑链路控制（LLC）子层和介质访问控制（MAC）子层&lt;/li&gt;
&lt;li&gt;传输单位：帧 Frame&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;链路管理：链路的建立、维持和释放&lt;/li&gt;
&lt;li&gt;帧同步：确定帧的开始与结束&lt;/li&gt;
&lt;li&gt;流量控制：点对点的，即链路层的相邻设备，采用滑动窗口机制&lt;/li&gt;
&lt;li&gt;差错控制：将有差错的物理线路改进为对网络层来说无差错的数据链路，采用奇偶校检码和循环冗余编码（CRC）&lt;/li&gt;
&lt;li&gt;透明传输：使得不论什么样的比特组合都可以在数据链路层传输&lt;/li&gt;
&lt;li&gt;物理寻址：向每个帧的头部加入了源MAC地址和目的MAC地址&lt;/li&gt;
&lt;li&gt;访问控制：当单个线路被多个设备共享时，数据链路层的MAC子层用于帮助确定哪个设备在给定时间控制信道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设备：网桥，交换机&lt;/li&gt;
&lt;li&gt;协议：HDLC协议，PPP协议，ARP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：数据包（分组） Packet&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;路由转发：确定哪条路由适合从源到目的地&lt;/li&gt;
&lt;li&gt;逻辑寻址：向数据包头部加入了目的IP地址和源IP地址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设备：路由器&lt;/li&gt;
&lt;li&gt;协议：IP，ICMP，IGMP，RIP，OSPF，BGP，RARP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;传输层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;传输单位：数据报（报文）Segments&lt;/li&gt;
&lt;li&gt;功能作用：

&lt;ul&gt;
&lt;li&gt;提供面向连接的TCP和无连接的UDP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会话层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主要为两个会话层实体进行会话，而进行的对话连接的管理服务。提供的服务可使应用建立和维持会话，并能使会话获得同步。会话层使用校验点，可使通信会话在通信失效时从校验点继续恢复通信。这种能力对于传送大的文件极为重要。&lt;/li&gt;
&lt;li&gt;功能作用：对话管理，数据流同步和重新同步&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;表示层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;处理两个应用实体之间进行数据交换的语法问题，解决数据交换中存在的语法不一致以及数据表示方法不同等问题&lt;/li&gt;
&lt;li&gt;功能作用：数据编码的转换，数据加密与解密，数据压缩与恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;应用层&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接提供文件传输，电子邮件，网页浏览等服务给用户。&lt;/li&gt;
&lt;li&gt;协议：FTP，SMTP，POP3，HTTP，SSH，DNS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tcpip模型&#34;&gt;TCP/IP模型&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;网络接口层&lt;/li&gt;
&lt;li&gt;网际层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;路由算法&#34;&gt;路由算法&lt;/h1&gt;

&lt;h2 id=&#34;内部网关协议-igp&#34;&gt;内部网关协议 IGP&lt;/h2&gt;

&lt;p&gt;用于自治系统内部的路由协议&lt;/p&gt;

&lt;h3 id=&#34;rip协议&#34;&gt;RIP协议&lt;/h3&gt;

&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;基于Bellman-Ford（距离矢量）算法&lt;/li&gt;
&lt;li&gt;RIP使用跳数来衡量距离，每一条链路的成本为1，不考虑带宽，时延等因素&lt;/li&gt;
&lt;li&gt;跳数为&lt;strong&gt;16&lt;/strong&gt;，表示该网络&lt;strong&gt;不可达&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用UDP报文进行路由信息的交换&lt;/li&gt;
&lt;li&gt;RIP路由协议用“更新（UNPDATES）”和“请求（REQUESTS）”这两种分组来传输信息&lt;/li&gt;
&lt;li&gt;每隔30秒向&lt;strong&gt;相邻&lt;/strong&gt;路由器发送一次更新信息，若180秒内未收到某邻居发送的报文，则将该路由置为不可达，若300秒内未接收到，则将其从路由表中删除&lt;/li&gt;
&lt;li&gt;更新信息反映了该路由器所有的路由选择信息数据库，路由选择信息数据库的每个条目由“局域网上能达到的IP地址”和“与该网络的距离”两部分组成&lt;/li&gt;
&lt;li&gt;请求信息用于寻找网络上能发出RIP报文的其他设备&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;慢收敛问题&#34;&gt;慢收敛问题&lt;/h4&gt;

&lt;p&gt;任何距离向量路由选择协议（如RIP）都有一个问题，路由器不知道网络的全局情况，路由器必须依靠相邻路由器来获取网络的可达信息。由于路由选择更新信息在网络上传播慢，距离向量路由选择算法有一个慢收敛问题，这个问题将导致不一致性产生。&lt;/p&gt;

&lt;h4 id=&#34;更新算法&#34;&gt;更新算法&lt;/h4&gt;

&lt;p&gt;假设路由器A，收到了其邻居路由器B发来的更新信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先对更新信息中的所有距离加1&lt;/li&gt;
&lt;li&gt;若A中的路由表没有该网络的路由信息，则加入该网络，下一跳设置为B&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，且下一跳为B，则更新该网络的距离&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，下一跳不为B，且其距离小于当前距离，则更新下一跳为B，更新距离&lt;/li&gt;
&lt;li&gt;若A中路由表存在该网络，下一跳不为B，且其距离不小于当前距离，则不更新&lt;/li&gt;
&lt;li&gt;对于A中路由表存在的网络，但是更新信息中没有的网络，则不更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ospf协议&#34;&gt;OSPF协议&lt;/h3&gt;

&lt;p&gt;开放最短路径优先（OSPF）是链路状态路由协议，使用Dijkstra算法找到源路由器和目的地路由器之间的最佳路径。链路状态路由协议是使用触发更新的概念的协议。即，如果在学习的路由表中观察到变化，则触发更新，而不像距离矢量路由协议在一段时间内交换。&lt;/p&gt;

&lt;h4 id=&#34;特点-1&#34;&gt;特点&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;与大多数路由协议不同（参考BGP和RIP的工作过程），本协议不依赖于传输层协议（如TCP、UDP）提供数据传输、错误检测与恢复服务，数据包直接封装在IP协议（协议号89）内传输&lt;/li&gt;
&lt;li&gt;使用Dijkstra算法计算出到达每一网络的最短路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;外部网关协议-egp&#34;&gt;外部网关协议 EGP&lt;/h2&gt;

&lt;p&gt;用于自治系统间接口上的路由协议&lt;/p&gt;

&lt;h3 id=&#34;bgp协议&#34;&gt;BGP协议&lt;/h3&gt;

&lt;p&gt;BGP用于在不同的自治系统（AS）之间交换路由信息，运行在TCP协议之上。当两个AS需要交换路由信息时，每个AS都必须指定一个运行BGP的节点，来代表AS与其他的AS交换路由信息。这个节点可以是一个主机。但通常是路由器来执行BGP。两个AS中利用BGP交换信息的路由器也被称为边界网关（Border Gateway）或边界路由器（Border Router）。&lt;/p&gt;

&lt;h1 id=&#34;tcp协议&#34;&gt;TCP协议&lt;/h1&gt;

&lt;h2 id=&#34;特点-2&#34;&gt;特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;TCP是面向连接的，在传输数据之前必须先建立连接，传输完毕后释放连接&lt;/li&gt;
&lt;li&gt;TCP只支持点对点通信&lt;/li&gt;
&lt;li&gt;TCP提供可靠交付，保证数据无差错，不丢失，无重复，有序到达&lt;/li&gt;
&lt;li&gt;TCP提供全双工通信，双方都可以发送和接收数据&lt;/li&gt;
&lt;li&gt;面向字节流&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp可靠传输&#34;&gt;TCP可靠传输&lt;/h2&gt;

&lt;h3 id=&#34;差错控制&#34;&gt;差错控制：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;校验和：每个TCP报文段都包括检验和字段，校验和用来检查报文段是否出现传输错误，如果报文段出现传输错误，TCP检查出错就丢弃该报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;编号与确认&#34;&gt;编号与确认&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;TCP为报文编号，以实现报文的有序接收&lt;/li&gt;
&lt;li&gt;接收端检查报文是否出错，发现出错时就丢弃，不发确认；而发送端通过检查接收端的确认，判断发送的报文段是否已经正确到达目的地&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;超时重传&#34;&gt;超时重传&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;发送端根据发出的报文段在规定的时间内是否收到确认，从而来判断该报文段是否丢失或传输出错。超过一定时间未收到确认，则重新发送该报文段&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp流量控制与拥塞控制&#34;&gt;TCP流量控制与拥塞控制&lt;/h2&gt;

&lt;h3 id=&#34;滑动窗口&#34;&gt;滑动窗口：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;停止等待协议：发送窗口swnd=1，接收窗口rwnd=1

&lt;ul&gt;
&lt;li&gt;发送方每发送一个报文，则直到接收到接收方的确认报文才发送下一个报文&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;后退N协议：发送窗口swnd&amp;gt;1，接受窗口rwnd=1

&lt;ul&gt;
&lt;li&gt;发送方可以连续发送发送窗口内的报文，每当接收到一个错误帧，则需要重传该帧及之后的所有帧&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择重传协议：发送窗口swnd&amp;gt;1，接收窗口rwnd&amp;gt;1

&lt;ul&gt;
&lt;li&gt;只重传错误帧即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;慢启动与拥塞避免&#34;&gt;慢启动与拥塞避免&lt;/h3&gt;

&lt;h4 id=&#34;慢启动算法&#34;&gt;慢启动算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;初始时，设置拥塞窗口cwnd=1，表示可以传输一个最大的报文段MSS的数据，设置慢启动门限初值ssthresh&lt;/li&gt;
&lt;li&gt;当cwnd &amp;lt; ssthresh 时，每收到新报文的ACK，则拥塞窗口cwnd++，因此每过一个RTT，则cwnd*2，呈指数增长&lt;/li&gt;
&lt;li&gt;当cwnd &amp;gt;= ssthresh 时，改用拥塞避免算法
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;拥塞避免算法&#34;&gt;拥塞避免算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当 cwdn &amp;gt;= ssthresh 时，每过一个RTT，拥塞窗口cwnd++&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;超时重传拥塞发生&#34;&gt;超时重传（拥塞发生）&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将ssthresh置为拥塞发生时拥塞窗口cwnd大小的一半&lt;/li&gt;
&lt;li&gt;拥塞窗口cwnd大小置为1，改用慢启动算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;快重传与快恢复&#34;&gt;快重传与快恢复&lt;/h3&gt;

&lt;h4 id=&#34;快重传&#34;&gt;快重传&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每当发送端接收到三个重复确认帧时，则直接开启重传，而不等待RTO超时&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;快恢复&#34;&gt;快恢复&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;重新将慢开始门限ssthresh设置为拥塞窗口cwnd的一半&lt;/li&gt;
&lt;li&gt;将拥塞窗口cwnd设置为ssthresh，然后采用拥塞避免算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;流量控制和拥塞控制的区别&#34;&gt;流量控制和拥塞控制的区别：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;流量控制是针对点对点的通信量的控制，是端到端的问题。流量控制所作的就是控制发送端的发送速率，以使得接收端能够接收。&lt;/li&gt;
&lt;li&gt;而拥塞控制是止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp连接管理&#34;&gt;TCP连接管理&lt;/h2&gt;

&lt;h3 id=&#34;tcp的建立过程&#34;&gt;TCP的建立过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;首先client发送连接请求，发送TCP报文，其中SYN=1， seq=x，然后clien进入&lt;strong&gt;SYN_SEND&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;server接收到连接请求，发送TCP报文，进行确认，其中SYN=1，ACK=1，seq=y，ack=x+1，然后server进入&lt;strong&gt;SYN_RCVD&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;clieten收到server发送过来的报文后，进行确认，其中ACK=1，seq=x+1，ack=y+1，然后client进入&lt;strong&gt;ESTABLISHED&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;server接收到该报文后也进入&lt;strong&gt;ESTABLISHED&lt;/strong&gt;状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tcp释放连接过程&#34;&gt;TCP释放连接过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;A发送断开连接请求，发送TCP报文，其中FIN=1，seq=x，然后A进入&lt;strong&gt;FIN_WAIT_1&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;B接收到A发送过来的断开请求后，发送TCP报文，其中ACK=1，seq=y,ack=x+1，然后B进入&lt;strong&gt;CLOSE_WAIT&lt;/strong&gt;状态，此时B仍然可以向A发送数据。&lt;/li&gt;
&lt;li&gt;A接收到B的确认后，进入&lt;strong&gt;FIN_WAIT_2&lt;/strong&gt;状态，A仍可接收数据&lt;/li&gt;
&lt;li&gt;B数据发送完毕后，发送断开连接请求，发送TCP报文，其中FIN=1，seq=y&#39;，然后B进入&lt;strong&gt;LAST_ACK&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;A接收到B的断连请求后，发送确认包，其中ACK=1，ack=y&#39;+1，然后A进入&lt;strong&gt;TIME_WAIT&lt;/strong&gt;状态，然后B接收到该确认包后关闭连接，进入&lt;strong&gt;CLOSED&lt;/strong&gt;状态&lt;/li&gt;
&lt;li&gt;A在等待一定时间（两个最大段生命周期 2MSL）后，进入&lt;strong&gt;CLOSED&lt;/strong&gt;状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;为何是三次握手&#34;&gt;为何是三次握手？&lt;/h3&gt;

&lt;p&gt;为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致。而要解决这个问题, 无论你在消息中包含什么信息，三次通信是理论上的最小值。所以三次握手不是TCP本身的要求, 而是为了满足“在不可靠信道上可靠地传输信息”这一需求所导致的。&lt;/p&gt;

&lt;h3 id=&#34;为何四次挥手&#34;&gt;为何四次挥手？&lt;/h3&gt;

&lt;p&gt;因此TCP是全双工通信的，需要双方分别断开连接。第一次挥手表示A数据发送完毕，请求断开连接；第二次挥手表示B同意A断开连接，B仍可向A发送数据，A仍可接收B发送的数据；第三次挥手表示B数据发送完毕，请求断开连接；第四次挥手表示A同意B断开连接。然后A在等待两个最大生命周期后，连接中断，以防B未接收到A发送的确认。&lt;/p&gt;

&lt;h3 id=&#34;为何timewair等待2msl&#34;&gt;为何TIME_WAIR等待2MSL？&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。&lt;/li&gt;
&lt;li&gt;防止已失效的连接请求报文段出现在本连接中。TIME_WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;udp协议&#34;&gt;UDP协议&lt;/h1&gt;

&lt;h2 id=&#34;特点-3&#34;&gt;特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;UDP是无连接的，因此减少了开销和发送数据的时延&lt;/li&gt;
&lt;li&gt;UDP尽最大努力交付，不保证可靠交付&lt;/li&gt;
&lt;li&gt;UDP是面向报文的，发送方的UDP对应用程序交下来的报文在添加首部后就向下交付给IP层，对交下来的报文既不合并也不拆分&lt;/li&gt;
&lt;li&gt;UDP没有拥塞控制，保证了实时性&lt;/li&gt;
&lt;li&gt;支持一对一，一对多，多对多的通信&lt;/li&gt;
&lt;li&gt;UDP首部只有8个字节，开销小&lt;/li&gt;
&lt;li&gt;UDP将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。&lt;/li&gt;
&lt;li&gt;应用：RIP协议，DNS协议，DHCP协议以及广泛应用在多媒体应用中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;udp分组结构&#34;&gt;UDP分组结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个UDP报文分UDP报头和UDP数据区两部分&lt;/li&gt;
&lt;li&gt;UDP报头包括4个字段：来源端口号，目的端口号，报文长度，校验和&lt;/li&gt;
&lt;li&gt;每个字段占用2个字节（即16个二进制位）&lt;/li&gt;
&lt;li&gt;数据报的长度是指包括报头和数据部分在内的总字节数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;dns&#34;&gt;DNS&lt;/h1&gt;

&lt;p&gt;DNS协议就是用来将域名解析到IP地址的一种协议，也可以将IP地址转换为域名。DNS是在名字服务器层次结构中实现的分布式数据库。它是用于客户端和服务器之间的消息交换的应用层协议。DNS协议基于UDP和TCP协议的，端口号53，用户到服务器采用UDP，DNS服务器通信采用TCP。&lt;/p&gt;

&lt;h2 id=&#34;dns域名结构&#34;&gt;DNS域名结构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通用域名：.com，.org，.net&lt;/li&gt;
&lt;li&gt;国家域名：.cn，.us&lt;/li&gt;
&lt;li&gt;反向域名：IP到域名的映射&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dns域名服务器&#34;&gt;DNS域名服务器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根域名服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;顶级域名服务器
负责管理所有的二级域名&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;权限域名服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;本地域名服务器&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;地址解析&#34;&gt;地址解析&lt;/h2&gt;

&lt;h3 id=&#34;递归查询&#34;&gt;递归查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器&lt;/li&gt;
&lt;li&gt;当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找&lt;/li&gt;
&lt;li&gt;如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器&lt;/li&gt;
&lt;li&gt;根名称服务器包含关于顶级域的至少一个服务器的信息。然后将查询发送到相应的顶级域服务器&lt;/li&gt;
&lt;li&gt;如果顶级域名服务器包含映射，则将响应将发送回根服务器，然后发送回主机的本地服务器&lt;/li&gt;
&lt;li&gt;若顶级域域名服务器不包含映射，则应包含目的主机的本地DNS服务器的IP地址&lt;/li&gt;
&lt;li&gt;目的主机的本地DNS服务器知道目的主机的IP地址，然后将发送回顶级域名服务器，然后发送给根域名服务器，然后发送到主机的本地域名服务器，最后到主机&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;迭代查询&#34;&gt;迭代查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当客户机提出查询请求时，首先在本地计算机的缓存中查找，如果在本地无法查询信息，则将查询请求发给本地DNS服务器&lt;/li&gt;
&lt;li&gt;当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则进行此记录进行解析，如果没有区域信息可以满足查询要求，服务器在本地缓存中查找&lt;/li&gt;
&lt;li&gt;如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到根域名DNS服务器&lt;/li&gt;
&lt;li&gt;根域DNS服务器将顶级域名服务器发送给本地DNS服务器&lt;/li&gt;
&lt;li&gt;然后本地DNS服务器向顶级域名服务器查询，顶级域名服务器将目的主机的IP地址或者目的主机的本地DNS服务器发送给本地DNS服务器&lt;/li&gt;
&lt;li&gt;本地DNS服务器向目的主机的本地DNS服务器查询，得到目的主机的IP地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;httphttps&#34;&gt;HTTP/HTTPS&lt;/h1&gt;

&lt;h2 id=&#34;两者的不同&#34;&gt;两者的不同&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;HTTP&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;HTTPS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;http://&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;https://&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;端口&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;80&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;443&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;安全性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不安全&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;安全&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;加密&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;未加密，明文传输&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;加密&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;证书&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不需要&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;短连接长连接&#34;&gt;短连接/长连接&lt;/h2&gt;

&lt;p&gt;HTTP的长连接和短连接本质上是TCP长连接和短连接。&lt;/p&gt;

&lt;h3 id=&#34;短连接&#34;&gt;短连接&lt;/h3&gt;

&lt;p&gt;在HTTP/1.0中，默认使用的是短连接。也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端浏览器访问的某个HTML或其他类型的 Web页中包含有其他的Web资源，如JavaScript文件、图像文件、CSS文件等；当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。&lt;/p&gt;

&lt;h3 id=&#34;长连接&#34;&gt;长连接&lt;/h3&gt;

&lt;p&gt;从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头有加入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connection: keep-alive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间。&lt;/p&gt;

&lt;h2 id=&#34;http-请求&#34;&gt;HTTP 请求&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;请求类型&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;GET&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求指定的页面信息，并返回实体主体&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;HEAD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;PUT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;向指定资源位置上传其最新内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;POST&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;DELETE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求服务器删除指定的资源&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;CONNECT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;OPTIONS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许客户端查看服务器的性能&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TRACE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;回显服务器收到的请求，主要用于测试或诊断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;http状态码&#34;&gt;HTTP状态码&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;状态码&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;200&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求成功&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;301&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;资源被永久转移到其他url&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;404&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;请求的资源不存在&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内部服务器错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;https-通信过程&#34;&gt;HTTPS 通信过程&lt;/h2&gt;

&lt;p&gt;HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。&lt;/p&gt;

&lt;p&gt;HTTPS在传输的过程中会涉及到三个密钥：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器端的公钥和私钥，用来进行非对称加密&lt;/li&gt;
&lt;li&gt;客户端生成的随机密钥，用来进行对称加密&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个HTTPS请求实际上包含了两次HTTP传输，可以细分为以下几步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端向服务器发起HTTPS请求，连接到服务器的443端口&lt;/li&gt;
&lt;li&gt;服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，服务器将自己的公钥发送给客户端&lt;/li&gt;
&lt;li&gt;客户端收到服务器端的公钥之后，验证服务器发送的数字证书的合法性。若合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束&lt;/li&gt;
&lt;li&gt;客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器&lt;/li&gt;
&lt;li&gt;服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密&lt;/li&gt;
&lt;li&gt;服务器将加密后的密文发送给客户端&lt;/li&gt;
&lt;li&gt;客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;常见问题&#34;&gt;常见问题&lt;/h1&gt;

&lt;h2 id=&#34;比较ipv4和ipv6&#34;&gt;比较IPv4和IPv6&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IPv4&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;IPv6&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址长度&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;32位&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;128位&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址配置&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;手动，DHCP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;自动，重新编号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址空间&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;小&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;大&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;安全性&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;依赖于应用层&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;内置安全功能IPSEC&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;地址表示&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;十进制&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;16进制&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;数据包流标识&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可用的，并在标头中使用流标签字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;校验和&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;可用&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不可用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;加密和身份验证&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;不提供&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;提供&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;请解释主机a是如何向主机b发送一条消息的&#34;&gt;请解释主机A是如何向主机B发送一条消息的&lt;/h2&gt;

&lt;h3 id=&#34;当主机a与主机b在同一个子网中&#34;&gt;当主机A与主机B在同一个子网中&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;构造目的地址为B的IP数据包&lt;/li&gt;
&lt;li&gt;根据主机A上的路由表内容，发现目的主机B位于相同子网&lt;/li&gt;
&lt;li&gt;查询本地ARP缓存，解析目的MAC地址&lt;/li&gt;
&lt;li&gt;若不存在，则发送ARP请求帧广播，网络中每一台主机收到后比对本机MAC地址，若不匹配则丢弃该ARP请求&lt;/li&gt;
&lt;li&gt;目的主机B将主机A的IP与MAC映射关系写入ARP缓存，发送向A主机ARP回复消息&lt;/li&gt;
&lt;li&gt;当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将主机B的MAC地址写入数据帧头部，发送该数据帧&lt;/p&gt;

&lt;h3 id=&#34;主机a与主机b不在同一个子网中&#34;&gt;主机A与主机B不在同一个子网中&lt;/h3&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造目的地址为B的IP数据包&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据主机A上的路由表内容对该IP数据包进行路由选择：路由选择算法，路由表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将路由的MAC地址封装到数据帧中发送出去&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;路由器接收到该数据帧，发现帧中的目的MAC地址与路由器接收端MAC地址相同，则解封装，上传到网络层&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;路由器找到数据包的目的IP地址，并查询路由表，然后将发送到下一个路由&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似地，直至到达目的主机所在子网，目的主机发现数据帧中的目的MAC与本机网卡MAC地址相同，拆除数据帧封装，上传到网络层&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络层比较数据包中的目的IP，然后拆除网络成封装，上传到传输层，确认，排序， 重组，然后上交到应用层&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;当在浏览器中输入一个url时发生了什么请逐步地尽可能详细的描述&#34;&gt;当在浏览器中输入一个url时发生了什么？请逐步地，尽可能详细的描述。&lt;/h2&gt;

&lt;h3 id=&#34;客户端构建并发送请求&#34;&gt;客户端构建并发送请求&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;应用层域名解析：通过负责域名解析的DNS服务获取网址的IP地址&lt;/li&gt;
&lt;li&gt;应用层生成HTTP请求报文&lt;/li&gt;
&lt;li&gt;传输层建立TCP连接，DNS使用UDP协议，HTTP使用TCP协议&lt;/li&gt;
&lt;li&gt;网络层通过IP协议，OSPF协议进行路由选择&lt;/li&gt;
&lt;li&gt;数据链路层实现网络相邻结点间可靠的数据通信&lt;/li&gt;
&lt;li&gt;物理层将数据链路层的帧转换成二进制比特流，在物理媒介上进行传输&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;网络传输&#34;&gt;网络传输&lt;/h3&gt;

&lt;p&gt;传输要经过各种网络设备，交换机，路由器等。&lt;/p&gt;

&lt;h4 id=&#34;交换机&#34;&gt;交换机&lt;/h4&gt;

&lt;p&gt;交换机是数据链路层设备，比特流到达交换机，交换机除了对比特流进行放大外，还根据源MAC地址进行学习，根据目的MAC地址进行转发。交换机根据数据帧中的目的MAC地址査询MAC地址表，把比特流从对应的端口发送出去&lt;/p&gt;

&lt;h4 id=&#34;路由器&#34;&gt;路由器&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;路由器收到比特流，转换成帧上传到数据链路层，&lt;/li&gt;
&lt;li&gt;路由器比较数据帧的目的MAC地址，如果有与路由器接收端口相同的MAC地址，则路由器的数据链路层把数据帧进行解封装，然后上传到路由器的网络层&lt;/li&gt;
&lt;li&gt;路由器找到数据包的目的IP地址，并查询路由表，将数据从入端口转发到出端口。&lt;/li&gt;
&lt;li&gt;接着在网络层重新封装成数据包packet，下沉到数据链路层重新封装成帧frame，下沉到物理层，转换成二进制比特流，发送出去&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务端处理请求返回&#34;&gt;服务端处理请求返回&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;服务器接收到这个比特流，把比特流转换成帧格式，上传到数据链路层&lt;/li&gt;
&lt;li&gt;服务器发现数据帧中的目的MAC地址与本网卡的MAC地址相同，服务器拆除数据链路层的封装后，把数据包上传到网络层&lt;/li&gt;
&lt;li&gt;服务器的网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，服务器拆除网络层的封装后，把数据分段上传到传输层&lt;/li&gt;
&lt;li&gt;传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性&lt;/li&gt;
&lt;li&gt;数据最后被传到服务器的应用层&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;浏览器渲染&#34;&gt;浏览器渲染&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;客户机接受到二进制比特流之后，把比特流转换成帧格式，上传到数据链路层&lt;/li&gt;
&lt;li&gt;客户机发现数据帧中的目的MAC地址与本网卡的MAC地址相同，拆除数据链路层的封装后，把数据包上传到网络层&lt;/li&gt;
&lt;li&gt;网络层比较数据包中的目的IP地址，发现与本机的IP地址相同，拆除网络层的封装后，把数据分段上传到传输层&lt;/li&gt;
&lt;li&gt;传输层对数据分段进行确认、排序、重组，确保数据传输的可靠性&lt;/li&gt;
&lt;li&gt;数据最后被传到应用层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://13ean.github.io/about/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/about/</guid>
      <description>&lt;p&gt;该Blog用于记录13ean的生活以及学习的点点滴滴。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://13ean.github.io/2019/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</guid>
      <description>&lt;h1 id=&#34;进程管理&#34;&gt;进程管理&lt;/h1&gt;

&lt;h2 id=&#34;进程与线程&#34;&gt;进程与线程&lt;/h2&gt;

&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;

&lt;p&gt;进程是程序关于某个数据集合的运行过程，进程是一个活动实体。进程是系统进行资源分配的基本单位。&lt;/p&gt;

&lt;h4 id=&#34;守护进程&#34;&gt;守护进程&lt;/h4&gt;

&lt;p&gt;Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。&lt;/p&gt;

&lt;p&gt;它们常常在系统引导装入时启动，仅在系统关闭时才终止。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。&lt;/p&gt;

&lt;p&gt;用户层守护进程的父进程是 init进程（进程ID为1）。对于用户层守护进程，因为它真正的父进程在 fork 出子进程后就先于子进程 exit 退出了，所以它是一个由 init 继承的孤儿进程。&lt;/p&gt;

&lt;h4 id=&#34;僵尸进程&#34;&gt;僵尸进程&lt;/h4&gt;

&lt;p&gt;在一个进程调用了exit之后，该进程并非马上就消失掉，而是留下一个称为僵尸进程（Zombie）的数据结构。在Linux进程的5种状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。&lt;/p&gt;

&lt;p&gt;收割僵尸进程的方法是通过kill命令手工向其父进程发送SIGCHLD信号。如果其父进程仍然拒绝收割僵尸进程，则终止父进程，使得init进程收养僵尸进程。init进程周期执行wait系统调用收割其收养的所有僵尸进程。&lt;/p&gt;

&lt;h4 id=&#34;孤儿进程&#34;&gt;孤儿进程&lt;/h4&gt;

&lt;p&gt;孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。&lt;/p&gt;

&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;

&lt;p&gt;线程是进程中的一个实体，是操作系统进行调度的基本单位，但不是资源分配的基本单位。线程除了必须的PC和寄存器外，几乎不拥有系统资源。&lt;/p&gt;

&lt;h3 id=&#34;进程与线程的关系&#34;&gt;进程与线程的关系&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个进程可以由多个线程组成&lt;/li&gt;
&lt;li&gt;进程是资源分配的最小单位，线程是程序执行的最小单位&lt;/li&gt;
&lt;li&gt;进程有自己独立的地址空间，同一个进程内的线程共享该进程的所有资源，共享该进程的地址空间。因此线程切换开销较小&lt;/li&gt;
&lt;li&gt;线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。&lt;/li&gt;
&lt;li&gt;每个线程有自己的堆栈和局部变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;协程&#34;&gt;协程&lt;/h2&gt;

&lt;p&gt;协程是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置；&lt;/p&gt;

&lt;h3 id=&#34;协程的优点&#34;&gt;协程的优点：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;跨平台，跨体系结构&lt;/li&gt;
&lt;li&gt;无需线程上下文切换的开销&lt;/li&gt;
&lt;li&gt;无需原子操作锁定及同步的开销，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了&lt;/li&gt;
&lt;li&gt;方便切换控制流，简化编程模型&lt;/li&gt;
&lt;li&gt;高并发，高扩展&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;协程的缺点&#34;&gt;协程的缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;无法利用多核资源：协程的本质是个单线程&lt;/li&gt;
&lt;li&gt;可以通过多进程+协程的方法来利用CPU的多核，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;进程间通信-ipc&#34;&gt;进程间通信 IPC&lt;/h2&gt;

&lt;h3 id=&#34;管道匿名管道pipe&#34;&gt;管道/匿名管道(pipe)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道&lt;/li&gt;
&lt;li&gt;只能用于父子进程或者兄弟进程之间&lt;/li&gt;
&lt;li&gt;数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;有名管道fifo&#34;&gt;有名管道（FIFO）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;允许无亲缘关系进程间的通信&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;信号量semaphore&#34;&gt;信号量（semaphore）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;信号量是一个计数器，用于多进程对共享数据的访问&lt;/li&gt;
&lt;li&gt;主要作为进程间以及同一进程不同线程之间的同步手段&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;共享内存&#34;&gt;共享内存&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使得多个进程可以可以直接读写同一块内存空间&lt;/li&gt;
&lt;li&gt;由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥
&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息队列&#34;&gt;消息队列&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示&lt;/li&gt;
&lt;li&gt;消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;信号&#34;&gt;信号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;套接字&#34;&gt;套接字&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;更为一般的进程间通信机制，可用于不同机器之间的进程间通信&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;线程通信&#34;&gt;线程通信&lt;/h2&gt;

&lt;h3 id=&#34;线程通信方式&#34;&gt;线程通信方式&lt;/h3&gt;

&lt;h4 id=&#34;全局变量&#34;&gt;全局变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;由于多个线程可能更改全局变量，因此全局变量最好声明为volatile&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;消息传递&#34;&gt;消息传递&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每一个线程都可以拥有自己的消息队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;事件&#34;&gt;事件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以通过对事件的触发状态进行改变，从而实现线程间的通信和同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;线程同步方式&#34;&gt;线程同步方式&lt;/h3&gt;

&lt;p&gt;线程间通信的主要目的是用于线程同步，所以线程没有像进程通信中用于数据交换的通信机制。主要包括互斥锁，读写锁，条件变量。&lt;/p&gt;

&lt;h4 id=&#34;互斥锁与临界区&#34;&gt;互斥锁与临界区&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;互斥锁是一种用于多线程编程中，防止多个线程同时对同一公共资源（比如全局变量）进行读写的机制&lt;/li&gt;
&lt;li&gt;临界区域指的是一块对公共资源进行访问的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;自旋锁&#34;&gt;自旋锁&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;用于多线程同步的一种锁，线程反复检查锁变量是否可用&lt;/li&gt;
&lt;li&gt;由于线程在这一过程中保持执行，因此是一种忙等待。一旦获取了自旋锁，线程会一直保持该锁，直至显式释放自旋锁&lt;/li&gt;
&lt;li&gt;自旋锁避免了进程上下文的调度开销，因此对于线程只会阻塞很短时间的场合是有效的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归死锁：&lt;/li&gt;
&lt;li&gt;过多占用CPU资源：&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;读写锁&#34;&gt;读写锁&lt;/h4&gt;

&lt;p&gt;读写锁允许多个线程同时读共享数据，而对写操作是互斥的&lt;/p&gt;

&lt;h5 id=&#34;读优先的读写锁&#34;&gt;读优先的读写锁&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class rwLock() {
publicn
    rwLock() : read_count(0) {
        pthread_mutex_init(&amp;amp;read_mtx, NULL);
        pthread_mutex_init(&amp;amp;write_mtx, NULL);
    }
    ~rwLock() {
        pthread_mutex_destroy(&amp;amp;read_mtx);
        pthread_mutex_destroy(&amp;amp;write_mtx);
    }
    void readLock() {
        pthread_mutex_lock(&amp;amp;read_mtx);
        if (++read_count == 1) {
            pthread_mutex_lock(&amp;amp;write_mtx);
        }
        pthread_mutex_unlock(&amp;amp;read_mtx);
    }

    void readUnlock() {
        pthread_mutex_lock(&amp;amp;read_mtx);
        if (--read_count == 0) {
            ptrhead_mutex_unlock(&amp;amp;write_mtx);
        }
        pthread_mutex_unlock(&amp;amp;read_mtx)
    }

    void writeLock() {
        pthread_mutex_lock(&amp;amp;write_mtx);
    }

    void writeUnlock() {
        pthread_mutex_unlock(&amp;amp;write_mtx);
    }

private:
    pthread_mutex_t read_mtx;
    pthread_mutex_t write_mtx;
    size_t read_count;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;写优先的读写锁&#34;&gt;写优先的读写锁&lt;/h5&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class rwLock() {
public:
    rwLock() : refCount(0), readWaiter(0), writeWaiter(0) {
        pthread_mutex_init(&amp;amp;rwMutex, NULL);
        pthread_cond_inti(&amp;amp;readCond, NULL);
        pthread_cond_inti(&amp;amp;writeCond, NULL);
    }

    ~rwLock() {
        pthread_mutex_destroy(&amp;amp;rwMutex);
        pthread_cond_destroy(&amp;amp;readCond);
        pthread_cond_destroy(&amp;amp;writeCond);
    }

    void readLock() {
        pthread_mutex_lock(&amp;amp;rwMutex);
        while (refCount &amp;lt; 0) {
            ++readWaiter;
            ptreahd_cond_wait(&amp;amp;readCond, &amp;amp;rwMutex);
            --readWaiter;
        }
        ++refCount;
        pthread_mutex_unlock(&amp;amp;rwMutex);
    }

    void writeLock() {
        pthread_mutex_lock(&amp;amp;rwMutex);
        while (refcount != 0) {
            ++writeWaiter;
            pthread_cond_wait(&amp;amp;writeCond, &amp;amp;rwMutex);
            --writeWaiter;
        }
        refCount = -1;
        pthread_mutex_unlock(&amp;amp;rwMutex);
    }

    void unlock() {
        pthread_mutex_lock(&amp;amp;rwMutex);
        if (refCount == -1) {
            refCount = 0;
        } else {
            refCount--;
        }
        if (refCount == 0) {
            if (writeWaiter &amp;gt; 0) {
                pthread_cond_signal(&amp;amp;writeCond);
            } else if (readWaiter &amp;gt; 0) {
                pthread_cond_signal(&amp;amp;readCond);
            }
        }
        pthread_mutex_unlock(&amp;amp;rwMutex);
    }
private:
    int refCount;
    int readWaiter;
    int writeWaiter;
    pthread_mutex_t rwMutex;
    pthread_cond_t readCond;
    pthread_cond_t writeCond;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;条件变量&#34;&gt;条件变量&lt;/h4&gt;

&lt;p&gt;条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用&lt;/p&gt;

&lt;h3 id=&#34;信号量机制&#34;&gt;信号量机制&lt;/h3&gt;

&lt;p&gt;包括无名线程信号量与有名线程信号量&lt;/p&gt;

&lt;h3 id=&#34;信号机制&#34;&gt;信号机制&lt;/h3&gt;

&lt;p&gt;类似于进程间信号通信&lt;/p&gt;

&lt;h2 id=&#34;进程调度&#34;&gt;进程调度&lt;/h2&gt;

&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;

&lt;h4 id=&#34;产生死锁的四个必要条件&#34;&gt;产生死锁的四个必要条件&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;保持并请求：进程已占用一部分资源，申请更多资源，且不会释放已占有的资源&lt;/li&gt;
&lt;li&gt;不可剥夺：进程已经占用的资源，不可以被抢占&lt;/li&gt;
&lt;li&gt;互斥：任一时刻只允许一个进程对该资源进行访问&lt;/li&gt;
&lt;li&gt;循环等待：请求资源的进程形成环状&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;死锁处理&#34;&gt;死锁处理&lt;/h4&gt;

&lt;h5 id=&#34;死锁预防&#34;&gt;死锁预防&lt;/h5&gt;

&lt;p&gt;采用某种策略限制进程对资源的请求，系统任何时刻都不满足死锁的必要条件。死锁预防主要是针对死锁的四个必要条件进行的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;破坏互斥条件：某些设备可以通过SPOOLING技术将独占资源转换共享资源&lt;/li&gt;
&lt;li&gt;破坏不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。&lt;/li&gt;
&lt;li&gt;破坏保持并请求条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。&lt;/li&gt;
&lt;li&gt;破坏循环等待条件：资源有序分配&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&#34;死锁避免&#34;&gt;死锁避免&lt;/h5&gt;

&lt;p&gt;某一时刻，若系统能按某种顺序为每个进程分配所需资源，是每个进程都能顺利完成，则此时系统处于安全状态。否则，为不安全状态。&lt;/p&gt;

&lt;p&gt;银行家算法&lt;/p&gt;

&lt;h5 id=&#34;死锁检测与恢复&#34;&gt;死锁检测与恢复&lt;/h5&gt;

&lt;h6 id=&#34;资源分配图&#34;&gt;资源分配图：&lt;/h6&gt;

&lt;p&gt;系统死锁，可利用资源分配图来描述。用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，用框中的一个点代表一类资源中的一个资源。从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。&lt;/p&gt;

&lt;h6 id=&#34;死锁定理&#34;&gt;死锁定理&lt;/h6&gt;

&lt;p&gt;可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在资源分配图中，找出既不阻塞又不是孤点的进程 &lt;span  class=&#34;math&#34;&gt;\(P_i\)&lt;/span&gt;（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。&lt;/li&gt;
&lt;li&gt;进程 &lt;span  class=&#34;math&#34;&gt;\(P_i\)&lt;/span&gt; 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。若能消去图中所有的边，则称该图是可完全简化的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理。&lt;/p&gt;

&lt;h6 id=&#34;死锁恢复&#34;&gt;死锁恢复：&lt;/h6&gt;

&lt;ol&gt;
&lt;li&gt;资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。&lt;/li&gt;
&lt;li&gt;撤销进程法：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。&lt;/li&gt;
&lt;li&gt;进程回退法：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;内存管理&#34;&gt;内存管理&lt;/h1&gt;

&lt;h2 id=&#34;进程的内存布局&#34;&gt;进程的内存布局&lt;/h2&gt;

&lt;p&gt;进程对应的内存空间中所包含的5种不同的数据区&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;程序代码段 text：存储目标文件的一部分或包含可执行指令的程序的虚拟地址空间的相应部分的位置，并且通常是只读且固定大小的。&lt;/li&gt;
&lt;li&gt;数据段 data：存储已初始化的常量和静态变量&lt;/li&gt;
&lt;li&gt;bss段：存储未初始化的常量和静态变量&lt;/li&gt;
&lt;li&gt;heap 堆：在.bss数据段的末尾开始，向高地址增长。用于存放进程运行中被动态分配的内存段&lt;/li&gt;
&lt;li&gt;stack 栈：挨着heap，两者相对增长。存放程序临时创建的局部变量。此外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;虚拟内存&#34;&gt;虚拟内存&lt;/h2&gt;

&lt;h3 id=&#34;请求分页管理&#34;&gt;请求分页管理&lt;/h3&gt;

&lt;h3 id=&#34;请求分段管理&#34;&gt;请求分段管理&lt;/h3&gt;

&lt;h3 id=&#34;请求段页式管理&#34;&gt;请求段页式管理&lt;/h3&gt;
</description>
    </item>
    
  </channel>
</rss>